<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Greatest Toy Solar System</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Indie+Flower&display=swap');

    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Indie Flower', cursive;
      background-color: #000;
    }

    #info {
      position: absolute;
      top: calc(10px + var(--safe-top));
      width: 100%;
      text-align: center;
      color: #fff;
      pointer-events: none;
      font-size: 18px;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.75);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
      font-family: 'Indie Flower', cursive;
      color: #fff;
      max-width: 250px;
      transition: transform 0.3s ease;
    }

    .control-section {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }

    .control-section:first-child {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }

    .control-section button {
      width: 100%;
    }

    .planet-label {
      position: absolute;
      color: #fff;
      background: rgba(0, 0, 0, 0.7);
      padding: 3px 8px;
      border-radius: 12px;
      pointer-events: none;
      font-family: 'Indie Flower', cursive;
      font-size: 14px;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.1);
    }

    .hand-drawn {
      border: 2px dashed #999;
      box-shadow: 0 0 0 4px #fff, 0 0 10px rgba(255, 255, 255, 0.2);
      background-color: rgba(255, 255, 255, 0.3);
    }

    button {
      font-family: 'Indie Flower', cursive;
      background-color: rgba(255, 255, 255, 0.2);
      border: 1px solid #888;
      color: #fff;
      border-radius: 8px;
      padding: 5px 10px;
      margin: 5px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    button:hover {
      transform: translateY(-2px);
      background-color: rgba(255, 255, 255, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    select {
      font-family: 'Indie Flower', cursive;
      background-color: rgba(255, 255, 255, 0.2);
      border: 1px solid #888;
      color: #fff;
      border-radius: 8px;
      padding: 5px 10px;
      cursor: pointer;
    }

    select option {
      background-color: #000;
      color: #fff;
    }

    input[type="file"] {
      font-family: 'Indie Flower', cursive;
      background-color: rgba(255, 255, 255, 0.2);
      border: 1px solid #888;
      color: #fff;
      border-radius: 8px;
      padding: 5px;
      font-size: 11px;
      cursor: pointer;
    }

    input[type="file"]::file-selector-button {
      font-family: 'Indie Flower', cursive;
      background-color: rgba(255, 255, 255, 0.3);
      border: 1px solid #888;
      color: #fff;
      border-radius: 5px;
      padding: 3px 8px;
      cursor: pointer;
    }

    input[type="file"]::file-selector-button:hover {
      background-color: rgba(255, 255, 255, 0.5);
    }

    #audioControls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.75);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
      font-family: 'Indie Flower', cursive;
      color: #fff;
      max-width: 250px;
      transition: transform 0.3s ease;
    }

    .audio-section {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }

    .audio-section:first-child {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }

    .volume-control {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 5px;
    }

    .volume-control label {
      font-size: 12px;
      min-width: 60px;
    }

    .volume-control input[type="range"] {
      flex: 1;
    }

    /* Collapsible panel controls for both desktop and mobile */
    .control-panel-header {
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 0;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .control-panel-header::after {
      content: '‚ñº';
      font-size: 12px;
      transition: transform 0.3s ease;
    }

    .control-panel-header.collapsed::after {
      transform: rotate(-90deg);
    }

    .control-panel-content {
      max-height: 500px;
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease;
      opacity: 1;
    }

    .control-panel-content.collapsed {
      max-height: 0;
      opacity: 0;
    }

    /* Mobile responsive styles */
    @media (max-width: 768px) {
      /* iOS Safari fix:
         - use safe-area insets so panels aren't under the home indicator / notch
         - use --vvh (visual viewport height) so panels stay reachable when the URL bar changes size
      */
      #controls, #audioControls {
        max-width: calc(100vw - 20px - var(--safe-left) - var(--safe-right));
        width: calc(100vw - 20px - var(--safe-left) - var(--safe-right));
        left: calc(10px + var(--safe-left));
        right: auto;

        /* default: dock at bottom, above the home indicator */
        bottom: calc(10px + var(--safe-bottom));
        top: auto;

        /* keep content reachable */
        max-height: calc(var(--vvh) - 120px - var(--safe-top) - var(--safe-bottom));
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;

        font-size: 14px;
      }

      /* Audio panel: dock near the top (below the top bar + notch) */
      #audioControls {
        bottom: auto;
        top: calc(60px + var(--safe-top));
      }

      #info {
        font-size: 16px;
        top: 5px;
      }

      button {
        padding: 8px 12px;
        font-size: 14px;
        margin: 3px;
        touch-action: manipulation;
      }

      select {
        padding: 8px 10px;
        font-size: 14px;
      }

      input[type="range"] {
        height: 30px;
      }

      .volume-control label {
        font-size: 13px;
        min-width: 70px;
      }
    }

    /* Extra small mobile devices */
    @media (max-width: 400px) {
      #controls, #audioControls {
        font-size: 13px;
        padding: 8px;
      }

      button {
        padding: 6px 10px;
        font-size: 13px;
      }

      select {
        font-size: 13px;
      }

      .volume-control label {
        font-size: 12px;
        min-width: 60px;
      }
    }
  
    /* =========================================================
       UI UPGRADE: Glass Observatory + Kid/Nerd Modes + Focus Card
       ========================================================= */
    :root{
      
      --vvh: 100vh; /* visual viewport height (patched by JS on iOS Safari) */
      --safe-top: env(safe-area-inset-top);
      --safe-right: env(safe-area-inset-right);
      --safe-bottom: env(safe-area-inset-bottom);
      --safe-left: env(safe-area-inset-left);
--ui-bg: rgba(8, 12, 20, 0.58);
      --ui-stroke: rgba(255,255,255,0.14);
      --ui-glow: rgba(120,180,255,0.35);
      --ui-glow2: rgba(255,120,220,0.22);
      --ui-radius: 16px;
      --ui-scale: 1;
      --ui-text: rgba(255,255,255,0.92);
      --ui-muted: rgba(255,255,255,0.72);
    }

    body{
      transform-origin: top left;
    }

    /* top bar */
    #topBar{
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      align-items: center;
      padding: calc(8px * var(--ui-scale)) calc(10px * var(--ui-scale));
      border-radius: 999px;
      background: var(--ui-bg);
      border: 1px solid var(--ui-stroke);
      backdrop-filter: blur(10px) saturate(1.2);
      -webkit-backdrop-filter: blur(10px) saturate(1.2);
      box-shadow: 0 12px 40px rgba(0,0,0,0.45), 0 0 0 1px rgba(255,255,255,0.04) inset;
      z-index: 20;
      color: var(--ui-text);
      user-select: none;
    }
    #topBar .pill{
      display:flex;
      align-items:center;
      gap:8px;
      padding: calc(6px * var(--ui-scale)) calc(10px * var(--ui-scale));
      border-radius: 999px;
      border: 1px solid var(--ui-stroke);
      background: rgba(255,255,255,0.06);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.25) inset;
    }
    #topBar .brand{
      font-family: 'Dancing Script', cursive;
      font-weight: 700;
      letter-spacing: 0.5px;
      font-size: calc(18px * var(--ui-scale));
      text-shadow: 0 0 18px rgba(255,255,255,0.2);
      padding-right: 6px;
    }
    #topBar button, #topBar select{
      margin: 0;
      font-size: calc(13px * var(--ui-scale));
    }

    /* Glass panels (reuse your IDs so existing JS keeps working) */
    #controls, #audioControls{
      background: var(--ui-bg);
      border: 1px solid var(--ui-stroke);
      border-radius: var(--ui-radius);
      backdrop-filter: blur(14px) saturate(1.25);
      -webkit-backdrop-filter: blur(14px) saturate(1.25);
      box-shadow:
        0 18px 60px rgba(0,0,0,0.55),
        0 0 0 1px rgba(255,255,255,0.05) inset,
        0 0 36px var(--ui-glow);
    }

    /* subtle animated shimmer */
    #controls::before, #audioControls::before{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: inherit;
      pointer-events:none;
      background: radial-gradient(600px 180px at 10% 10%, rgba(120,180,255,0.10), transparent 55%),
                  radial-gradient(500px 220px at 90% 15%, rgba(255,120,220,0.08), transparent 60%),
                  radial-gradient(600px 260px at 50% 110%, rgba(120,255,190,0.06), transparent 60%);
      filter: blur(2px);
      opacity: 0.9;
      mix-blend-mode: screen;
    }

    #controls, #audioControls{
      position: fixed;
      z-index: 10;
    }

    /* Make headings feel like a console */
    .control-panel-header{
      font-size: calc(15px * var(--ui-scale));
      letter-spacing: 0.3px;
      color: var(--ui-text);
      padding: calc(8px * var(--ui-scale)) calc(8px * var(--ui-scale));
      margin: 0 0 calc(8px * var(--ui-scale)) 0;
      border-radius: 12px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .control-panel-header::after{ opacity: 0.85; }

    .control-section, .audio-section{
      border-top: 1px solid rgba(255,255,255,0.10);
    }

    /* Buttons / inputs as "holo controls" */
    button{
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.25) inset, 0 10px 24px rgba(0,0,0,0.25);
      border-radius: 12px;
    }
    button:hover{
      background: rgba(255,255,255,0.16);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.18) inset, 0 14px 30px rgba(0,0,0,0.30), 0 0 22px rgba(120,180,255,0.22);
    }
    select, input[type="file"]{
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
    }

    /* Focus card (planet info / actions) */
    #focusCard{
      position: absolute;
      right: 20px;
      top: 70px;
      width: min(340px, calc(100vw - 40px));
      background: var(--ui-bg);
      border: 1px solid var(--ui-stroke);
      border-radius: var(--ui-radius);
      backdrop-filter: blur(14px) saturate(1.2);
      -webkit-backdrop-filter: blur(14px) saturate(1.2);
      box-shadow: 0 18px 60px rgba(0,0,0,0.55), 0 0 36px var(--ui-glow2);
      color: var(--ui-text);
      padding: 14px;
      z-index: 15;
      display: none;
    }
    #focusCard .title{
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      font-weight: 700;
      letter-spacing: 0.2px;
      font-size: 18px;
      margin-bottom: 6px;
    }
    #focusCard .subtitle{
      color: var(--ui-muted);
      font-size: 13px;
      margin-bottom: 10px;
      line-height: 1.2;
    }
    #focusCard .row{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 13px;
      color: var(--ui-muted);
      padding: 6px 0;
      border-top: 1px solid rgba(255,255,255,0.10);
    }
    #focusCard .actions{
      display:flex;
      gap: 8px;
      margin-top: 12px;
    }
    #focusCard .actions button{
      flex: 1;
      margin: 0;
      padding: 8px 10px;
    }

    /* Kid vs Nerd mode */
    body.kid-mode .advanced { display: none !important; }
    body.kid-mode #audioControls { display: none; } /* kids: keep it simple; they can toggle Sound in top bar */
    body.kid-mode #controls { max-width: 260px; }
    body.kid-mode #info { opacity: 0.0; } /* top bar replaces it */

    /* UI scale */
    .ui-scale-80 { --ui-scale: 0.85; }
    .ui-scale-100{ --ui-scale: 1; }
    .ui-scale-120{ --ui-scale: 1.15; }
    .ui-scale-140{ --ui-scale: 1.30; }

    /* Mobile tweaks: keep focus card from covering everything */
    @media (max-width: 768px){
      #focusCard{
        right: 10px;
        left: 10px;
        top: auto;
        bottom: 10px;
        width: auto;
      }
      #topBar{
        top: calc(8px + var(--safe-top));
        gap: 8px;
        padding: 8px 10px;
        width: calc(100vw - 16px - var(--safe-left) - var(--safe-right));
        max-width: 740px;
      }
      #topBar .brand{
        font-size: 16px;
      }
    }

  
    /* Guided Tour overlay */
    #tourOverlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      z-index: 80;
      display:none;
    }
    #tourSpot{
      position:absolute;
      border-radius: 14px;
      outline: 3px solid rgba(180,220,255,0.9);
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.55), 0 10px 40px rgba(0,0,0,0.6);
      pointer-events:none;
      transition: all .18s ease;
    }
    #tourCard{
      position:absolute;
      max-width: 360px;
      background: rgba(10,14,20,0.72);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 16px;
      padding: 12px 12px 10px;
      color:#fff;
      box-shadow: 0 16px 60px rgba(0,0,0,0.55);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      transition: all .18s ease;
    }
    #tourCard .tTitle{ font-weight: 800; letter-spacing: .2px; margin-bottom: 6px; }
    #tourCard .tBody{ font-size: 13px; opacity: .92; line-height: 1.25; }
    #tourCard .tBtns{ display:flex; gap:8px; margin-top:10px; }
    #tourCard .tBtns button{ flex:1; margin:0; padding:8px 10px; }
    #tourCard .tMeta{ margin-top:8px; font-size: 12px; opacity:.75; display:flex; justify-content:space-between; }

  
    /* Museum-grade hover label */
    #hoverLabel{
      position: fixed;
      left: 0; top: 0;
      transform: translate(-9999px,-9999px);
      z-index: 60;
      pointer-events: none;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      letter-spacing: 0.2px;
      color: rgba(255,255,255,0.92);
      background: rgba(15, 23, 42, 0.55);
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      white-space: nowrap;
      opacity: 0;
      transition: opacity .12s ease;
    }
    #hoverLabel.show{ opacity: 1; }

  </style>
</head>

<body>
  <div id="info">‚ú® Spectacular Solar System ‚ú®</div>

  <div id="topBar" aria-label="Toy Solar System Controls">
    <div class="brand">‚ú® Toy Solar System</div>

    <div class="pill">
      <button id="modeToggle" title="Switch between Kid Mode and Nerd Mode">üßí Kid</button>
      <button id="soundQuickToggle" title="Show/Hide Sound Lab">üîä Sound</button>
      <button id="tourBtn" title="Guided Tour">üó∫Ô∏è Tour</button>
    </div>

    <div class="pill">
      <label for="presetSelect" style="font-size:12px; opacity:.85;">‚≠ê Preset</label>
      <select id="presetSelect">
        <option value="default" selected>Default</option>
        <option value="wow">WOW (Glow + Comets)</option>
        <option value="museum">Museum (Calm + Clear)</option>
        <option value="nightride">Night Ride (Moody)</option>
      </select>
    </div>

    <div class="pill">
      <label for="uiScale" style="font-size:12px; opacity:.85;">UI</label>
      <select id="uiScale">
        <option value="80">S</option>
        <option value="100" selected>M</option>
        <option value="120">L</option>
        <option value="140">XL</option>
      </select>
    </div>
  </div>

  <div id="focusCard" role="dialog" aria-label="Planet Focus">
    <div class="title">
      <span id="focusName">Planet</span>
      <button id="focusClose" title="Close" style="flex:0 0 auto; padding:6px 10px;">‚úï</button>
    </div>
    <div class="subtitle" id="focusFact">Tap a planet (or the selector) to focus. Try the Tour for a guided demo.</div>

    <div class="row"><span>Orbit radius</span><span id="focusOrbit">‚Äî</span></div>
    <div class="row"><span>Speed</span><span id="focusSpeed">‚Äî</span></div>
    <div class="row"><span>Moons</span><span id="focusMoons">‚Äî</span></div>

    <div class="actions">
      <button id="focusFollow">üé• Follow</button>
      <button id="focusReset">üß≠ Reset</button>
    </div>
  </div>

  <div id="tourOverlay" aria-label="Guided Tour" role="dialog" aria-modal="true">
    <div id="tourSpot"></div>
    <div id="tourCard">
      <div class="tTitle" id="tourTitle">Tour</div>
      <div class="tBody" id="tourBody">‚Ä¶</div>
      <div class="tBtns">
        <button id="tourBack">‚óÄ Back</button>
        <button id="tourNext">Next ‚ñ∂</button>
        <button id="tourSkip" title="End tour">‚úï</button>
      </div>
      <div class="tMeta">
        <span id="tourStep">1/1</span>
        <span>Tip: you can still orbit/zoom</span>
      </div>
    </div>
  </div>

  <div id="controls">
    <div class="control-panel-header" id="animationControlsHeader">üé¨ Animation Controls</div>
    <div class="control-panel-content" id="animationControlsContent">
    
    <div class="control-section">
      <button id="toggleAnimation">Pause</button>
    </div>

    <div class="control-section">
      <button id="toggleFreeze">Freeze (Place Asteroids)</button>
    </div>

    <div class="control-section">
      <button id="resetView">Reset View</button>
    </div>

    <div class="control-section advanced">
      <button id="toggleSatellites">Satellites: Highly Visible</button>
    </div>

    <div class="control-section">
      <div style="font-size: 12px; margin-bottom: 5px;">Speed:</div>
      <input type="range" id="speedControl" min="0" max="2" step="0.05" value="0.5" style="width: 100%;">
    </div>

    <div class="control-section advanced">
      <div style="font-size: 12px; margin-bottom: 5px;">View from:</div>
      <select id="planetSelector" style="width: 100%; font-size: 12px;">
        <option value="Sun">Sun</option>
      </select>
    </div>

    <div id="planeSelector" class="control-section advanced" style="display: none;">
      <div style="font-size: 12px; margin-bottom: 5px;">Placement Plane:</div>
      <select id="planeSelect" style="width: 100%; font-size: 12px;">
        <option value="0">North-South</option>
        <option value="90">East-West</option>
        <option value="45">45¬∞ Diagonal</option>
        <option value="135">135¬∞ Diagonal</option>
      </select>
    </div>
    </div>
  </div>

  <div id="audioControls">
    <div class="control-panel-header" id="audioControlsHeader">üéµ Audio Controls</div>
    <div class="control-panel-content" id="audioControlsContent">
    
    <div class="audio-section">
      <button id="toggleAudio" style="width: 100%;">Start Audio</button>
    </div>

    <div class="audio-section advanced">
      <div class="volume-control">
        <label>Master:</label>
        <input type="range" id="masterVolume" min="0" max="100" value="50">
      </div>
    </div>

    <div class="audio-section advanced">
      <div style="font-size: 12px; margin-bottom: 5px;">Background:</div>
      <select id="ambientType" style="width: 100%; font-size: 12px;">
        <option value="off">Off</option>
        <option value="white">White Noise</option>
        <option value="pink" selected>Pink Noise</option>
        <option value="celestial">Celestial</option>
      </select>
      <div class="volume-control">
        <label>Volume:</label>
        <input type="range" id="ambientVolume" min="0" max="100" value="30">
      </div>
    </div>

    <div class="audio-section advanced">
      <div style="font-size: 12px; margin-bottom: 5px;">Custom Loop:</div>
      <input type="file" id="customAudioFile" accept="audio/*" style="width: 100%; font-size: 10px;">
      <div class="volume-control">
        <label>Volume:</label>
        <input type="range" id="customVolume" min="0" max="100" value="50">
      </div>
    </div>

    <div class="audio-section advanced">
      <div style="font-size: 12px; margin-bottom: 5px;">Spatial Audio:</div>
      <label style="font-size: 11px; display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="spatialAudioEnabled" checked>
        Enable for objects
      </label>
      <div class="volume-control">
        <label>Volume:</label>
        <input type="range" id="spatialVolume" min="0" max="100" value="40">
      </div>
    </div>
    </div>
  </div>

  <script>
    // =============================================================================
    // COLLAPSIBLE PANEL CONTROLS - Works on both desktop and mobile
    // =============================================================================
    
    (function() {
      // Track if event listeners have been added
      let listenersAdded = false;
      
      // Function to setup collapsible panels
      function setupCollapsiblePanels() {
        if (listenersAdded) return;
        
        // Animation controls panel
        const animationHeader = document.getElementById('animationControlsHeader');
        const animationContent = document.getElementById('animationControlsContent');
        
        if (animationHeader && animationContent) {
          animationHeader.addEventListener('click', function() {
            this.classList.toggle('collapsed');
            animationContent.classList.toggle('collapsed');
          });
        }
        
        // Audio controls panel - start collapsed to save space
        const audioHeader = document.getElementById('audioControlsHeader');
        const audioContent = document.getElementById('audioControlsContent');
        
        if (audioHeader && audioContent) {
          // Start collapsed
          audioHeader.classList.add('collapsed');
          audioContent.classList.add('collapsed');
          
          audioHeader.addEventListener('click', function() {
            this.classList.toggle('collapsed');
            audioContent.classList.toggle('collapsed');
          });
        }
        
        listenersAdded = true;
      }
      
      // Setup collapsible panels on DOM ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupCollapsiblePanels);
      } else {
        setupCollapsiblePanels();
      }
    })();
    
    
    // =============================================================================
    // UI UPGRADE LAYER (Kid/Nerd mode, presets, focus card, UI scale)
    // =============================================================================
    (function(){
      const body = document.body;

      // Persist simple preferences
      const savedMode = localStorage.getItem('uiMode') || 'kid';
      const savedScale = localStorage.getItem('uiScale') || '100';

      function applyScale(v){
        body.classList.remove('ui-scale-80','ui-scale-100','ui-scale-120','ui-scale-140');
        body.classList.add(`ui-scale-${v}`);
      }
      function setMode(mode){
        const btn = document.getElementById('modeToggle');
        const isKid = (mode === 'kid');
        body.classList.toggle('kid-mode', isKid);
        if (btn) btn.textContent = isKid ? "üßí Kid" : "üß† Nerd";
        localStorage.setItem('uiMode', mode);
      }

      // Init mode + scale
      applyScale(savedScale);
      setMode(savedMode);

      // Wire UI scale
      const uiScale = document.getElementById('uiScale');
      if (uiScale){
        uiScale.value = savedScale;
        uiScale.addEventListener('change', (e)=>{
          const v = e.target.value;
          applyScale(v);
          localStorage.setItem('uiScale', v);
        });
      }

      // Sound quick toggle (show/hide audio panel even in nerd mode)
      const soundBtn = document.getElementById('soundQuickToggle');
      const audioPanel = document.getElementById('audioControls');
      if (soundBtn && audioPanel){
        soundBtn.addEventListener('click', ()=>{
          const isHidden = audioPanel.style.display === 'none';
          audioPanel.style.display = isHidden ? '' : 'none';
        });
      }

      // Mode toggle
      const modeBtn = document.getElementById('modeToggle');
      if (modeBtn){
        modeBtn.addEventListener('click', ()=>{
          const next = body.classList.contains('kid-mode') ? 'nerd' : 'kid';
          setMode(next);
          // In kid mode, ensure audio panel is hidden unless explicitly shown
          if (next === 'kid' && audioPanel) audioPanel.style.display = 'none';
          if (next === 'nerd' && audioPanel) audioPanel.style.display = '';
        });
      }

      // Focus card helpers (populated later once bodies exist)
      const focus = {
        card: document.getElementById('focusCard'),
        name: document.getElementById('focusName'),
        fact: document.getElementById('focusFact'),
        orbit: document.getElementById('focusOrbit'),
        speed: document.getElementById('focusSpeed'),
        moons: document.getElementById('focusMoons'),
        close: document.getElementById('focusClose'),
        follow: document.getElementById('focusFollow'),
        reset: document.getElementById('focusReset'),
      };
      if (focus.close && focus.card){
        focus.close.addEventListener('click', ()=> focus.card.style.display = 'none');
      }

      // Presets hook (actual rendering knobs set later once renderer/composer exist)
      window.__uiPresetRequested = (localStorage.getItem('preset') || 'default');
      const presetSelect = document.getElementById('presetSelect');
      if (presetSelect){
        presetSelect.value = window.__uiPresetRequested;
        presetSelect.addEventListener('change', (e)=>{
          window.__uiPresetRequested = e.target.value;
          localStorage.setItem('preset', window.__uiPresetRequested);
          window.dispatchEvent(new CustomEvent('ui:preset', { detail: window.__uiPresetRequested }));
        });
      }

      // Expose focus UI API to the rest of the app
      window.__setFocusCard = function(payload){
        if (!focus.card) return;
        if (!payload){
          focus.card.style.display = 'none';
          return;
        }
        focus.name.textContent = payload.name || '‚Äî';
        focus.fact.textContent = payload.fact || '';
        focus.orbit.textContent = payload.orbit || '‚Äî';
        focus.speed.textContent = payload.speed || '‚Äî';
        focus.moons.textContent = payload.moons || '‚Äî';
        focus.card.style.display = 'block';
      };

      window.__wireFocusButtons = function({onFollow, onReset}){
        if (focus.follow) focus.follow.onclick = onFollow || null;
        if (focus.reset) focus.reset.onclick = onReset || null;
      };
    
    // =============================================================================
    // MOBILE VIEWPORT FIX (iOS Safari): keep panels inside the *visual* viewport
    // =============================================================================
    (function(){
      function setVVH(){
        const h = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;
        document.documentElement.style.setProperty('--vvh', h + 'px');
      }
      setVVH();
      window.addEventListener('resize', setVVH);
      if (window.visualViewport){
        window.visualViewport.addEventListener('resize', setVVH);
        window.visualViewport.addEventListener('scroll', setVVH);
      }
    })();

})();


    // =============================================================================
    // AUDIO SYSTEM - Immersive Celestial Soundscape
    // =============================================================================
    
    class CelestialAudioSystem {
      constructor() {
        this.audioContext = null;
        this.isInitialized = false;
        this.isPlaying = false;
        
        // Audio nodes
        this.masterGain = null;
        this.ambientGain = null;
        this.customGain = null;
        this.spatialGain = null;
        
        // Noise generators
        this.whiteNoiseNode = null;
        this.pinkNoiseNode = null;
        this.celestialNode = null;
        this.currentAmbientNode = null;
        
        // Custom audio
        this.customAudioElement = null;
        this.customSourceNode = null;
        
        // Spatial audio
        this.spatialSources = new Map(); // Track spatial audio sources for objects
        
        // Settings
        this.ambientType = 'pink';
        this.spatialEnabled = true;
      }
      
      async initialize() {
        if (this.isInitialized) return;
        
        try {
          // Create audio context
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          // Create master gain (output)
          this.masterGain = this.audioContext.createGain();
          this.masterGain.gain.value = 0.5;
          this.masterGain.connect(this.audioContext.destination);
          
          // Create gain nodes for different audio types
          this.ambientGain = this.audioContext.createGain();
          this.ambientGain.gain.value = 0.3;
          this.ambientGain.connect(this.masterGain);
          
          this.customGain = this.audioContext.createGain();
          this.customGain.gain.value = 0.5;
          this.customGain.connect(this.masterGain);
          
          this.spatialGain = this.audioContext.createGain();
          this.spatialGain.gain.value = 0.4;
          this.spatialGain.connect(this.masterGain);
          
          // Create noise generators
          this.createNoiseGenerators();
          
          this.isInitialized = true;
          console.log('‚ú® Celestial audio system initialized');
          
        } catch (error) {
          console.error('Failed to initialize audio system:', error);
        }
      }
      
      createNoiseGenerators() {
        // White noise generator
        this.whiteNoiseNode = this.createWhiteNoise();
        
        // Pink noise generator (more pleasant, like ocean waves)
        this.pinkNoiseNode = this.createPinkNoise();
        
        // Celestial ambient (layered synthesis)
        this.celestialNode = this.createCelestialAmbient();
      }
      
      createWhiteNoise() {
        const bufferSize = 2 * this.audioContext.sampleRate;
        const noiseBuffer = this.audioContext.createBuffer(2, bufferSize, this.audioContext.sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
          const output = noiseBuffer.getChannelData(channel);
          for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
          }
        }
        
        const whiteNoise = this.audioContext.createBufferSource();
        whiteNoise.buffer = noiseBuffer;
        whiteNoise.loop = true;
        
        // Low-pass filter to make it less harsh
        const filter = this.audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 3000;
        
        whiteNoise.connect(filter);
        
        return { source: whiteNoise, filter: filter };
      }
      
      createPinkNoise() {
        const bufferSize = 2 * this.audioContext.sampleRate;
        const noiseBuffer = this.audioContext.createBuffer(2, bufferSize, this.audioContext.sampleRate);
        
        // Pink noise generation using Paul Kellet's algorithm
        for (let channel = 0; channel < 2; channel++) {
          const output = noiseBuffer.getChannelData(channel);
          let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
          
          for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
            b6 = white * 0.115926;
          }
        }
        
        const pinkNoise = this.audioContext.createBufferSource();
        pinkNoise.buffer = noiseBuffer;
        pinkNoise.loop = true;
        
        // Gentle low-pass filter for smoothness
        const filter = this.audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 2000;
        filter.Q.value = 0.5;
        
        pinkNoise.connect(filter);
        
        return { source: pinkNoise, filter: filter };
      }
      
      createCelestialAmbient() {
        // Create a celestial drone using multiple oscillators
        const oscillators = [];
        const gains = [];
        const merger = this.audioContext.createChannelMerger(2);
        
        // Fundamental frequencies for a cosmic, ethereal sound
        const frequencies = [55, 82.5, 110, 165, 220]; // A1, E2, A2, E3, A3 - perfect fifths
        
        frequencies.forEach((freq, index) => {
          const osc = this.audioContext.createOscillator();
          osc.type = 'sine';
          osc.frequency.value = freq;
          
          const gain = this.audioContext.createGain();
          gain.gain.value = 0.03 / (index + 1); // Quieter harmonics
          
          // Add slow LFO for movement
          const lfo = this.audioContext.createOscillator();
          lfo.type = 'sine';
          lfo.frequency.value = 0.1 + index * 0.05;
          
          const lfoGain = this.audioContext.createGain();
          lfoGain.gain.value = 0.01;
          
          lfo.connect(lfoGain);
          lfoGain.connect(gain.gain);
          
          osc.connect(gain);
          
          // Pan slightly for stereo width
          const panner = this.audioContext.createStereoPanner();
          panner.pan.value = (index % 2 === 0 ? -0.3 : 0.3) * (index / frequencies.length);
          
          gain.connect(panner);
          panner.connect(merger);
          
          oscillators.push(osc);
          gains.push(gain);
          
          lfo.start();
        });
        
        // Add a gentle filter sweep
        const filter = this.audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800;
        filter.Q.value = 1;
        
        // LFO for filter
        const filterLfo = this.audioContext.createOscillator();
        filterLfo.type = 'sine';
        filterLfo.frequency.value = 0.07;
        
        const filterLfoGain = this.audioContext.createGain();
        filterLfoGain.gain.value = 300;
        
        filterLfo.connect(filterLfoGain);
        filterLfoGain.connect(filter.frequency);
        
        merger.connect(filter);
        
        filterLfo.start();
        
        return { oscillators, gains, filter, filterLfo };
      }
      
      setAmbientType(type) {
        this.ambientType = type;
        if (this.isPlaying) {
          this.stopAmbient();
          if (type !== 'off') {
            this.startAmbient();
          }
        }
      }
      
      startAmbient() {
        if (!this.isInitialized || this.currentAmbientNode) return;
        
        try {
          switch (this.ambientType) {
            case 'white':
              this.whiteNoiseNode.source.start(0);
              this.whiteNoiseNode.filter.connect(this.ambientGain);
              this.currentAmbientNode = this.whiteNoiseNode;
              break;
              
            case 'pink':
              this.pinkNoiseNode.source.start(0);
              this.pinkNoiseNode.filter.connect(this.ambientGain);
              this.currentAmbientNode = this.pinkNoiseNode;
              break;
              
            case 'celestial':
              this.celestialNode.oscillators.forEach(osc => osc.start(0));
              this.celestialNode.filter.connect(this.ambientGain);
              this.currentAmbientNode = this.celestialNode;
              break;
          }
        } catch (error) {
          console.error('Error starting ambient audio:', error);
        }
      }
      
      stopAmbient() {
        if (!this.currentAmbientNode) return;
        
        try {
          if (this.currentAmbientNode === this.whiteNoiseNode) {
            this.whiteNoiseNode.filter.disconnect();
            this.whiteNoiseNode.source.stop();
            this.whiteNoiseNode = this.createWhiteNoise();
          } else if (this.currentAmbientNode === this.pinkNoiseNode) {
            this.pinkNoiseNode.filter.disconnect();
            this.pinkNoiseNode.source.stop();
            this.pinkNoiseNode = this.createPinkNoise();
          } else if (this.currentAmbientNode === this.celestialNode) {
            this.celestialNode.filter.disconnect();
            this.celestialNode.oscillators.forEach(osc => osc.stop());
            this.celestialNode = this.createCelestialAmbient();
          }
          
          this.currentAmbientNode = null;
        } catch (error) {
          console.error('Error stopping ambient audio:', error);
        }
      }
      
      loadCustomAudio(file) {
        if (!this.isInitialized) return;
        
        // Stop existing custom audio
        this.stopCustomAudio();
        
        const reader = new FileReader();
        reader.onload = (e) => {
          this.audioContext.decodeAudioData(e.target.result, (buffer) => {
            this.customAudioElement = buffer;
            if (this.isPlaying) {
              this.playCustomAudio();
            }
            console.log('‚ú® Custom audio loaded');
          }, (error) => {
            console.error('Error decoding audio:', error);
          });
        };
        reader.readAsArrayBuffer(file);
      }
      
      playCustomAudio() {
        if (!this.customAudioElement || this.customSourceNode) return;
        
        try {
          this.customSourceNode = this.audioContext.createBufferSource();
          this.customSourceNode.buffer = this.customAudioElement;
          this.customSourceNode.loop = true;
          this.customSourceNode.connect(this.customGain);
          this.customSourceNode.start(0);
        } catch (error) {
          console.error('Error playing custom audio:', error);
        }
      }
      
      stopCustomAudio() {
        if (this.customSourceNode) {
          try {
            this.customSourceNode.stop();
            this.customSourceNode.disconnect();
          } catch (error) {
            // Ignore errors when stopping
          }
          this.customSourceNode = null;
        }
      }
      
      // Spatial audio for nearby objects
      createSpatialSound(objectId, distance, pan) {
        if (!this.isInitialized || !this.spatialEnabled) return;
        
        // Check if we already have a source for this object
        let spatialSource = this.spatialSources.get(objectId);
        
        if (!spatialSource) {
          // Create a subtle whoosh/hum sound
          const osc = this.audioContext.createOscillator();
          osc.type = 'sine';
          osc.frequency.value = 80 + Math.random() * 40; // Low frequency hum
          
          const gainNode = this.audioContext.createGain();
          gainNode.gain.value = 0;
          
          const panner = this.audioContext.createStereoPanner();
          
          osc.connect(gainNode);
          gainNode.connect(panner);
          panner.connect(this.spatialGain);
          
          osc.start();
          
          spatialSource = { osc, gainNode, panner, lastUpdate: Date.now() };
          this.spatialSources.set(objectId, spatialSource);
        }
        
        // Update spatial parameters based on distance and position
        const maxDistance = 30; // Objects closer than this can be heard
        const minDistance = 5;  // Minimum distance for maximum volume
        
        if (distance < maxDistance) {
          // Calculate volume based on distance (inverse square law, but clamped)
          let volume = 0;
          if (distance < minDistance) {
            volume = 0.15; // Maximum volume
          } else {
            volume = 0.15 * Math.pow(minDistance / distance, 2);
          }
          
          // Very subtle - celestial ambience
          volume *= 0.3;
          
          // Smooth volume changes
          spatialSource.gainNode.gain.linearRampToValueAtTime(
            volume,
            this.audioContext.currentTime + 0.1
          );
          
          // Binaural panning (-1 left, 1 right)
          spatialSource.panner.pan.linearRampToValueAtTime(
            Math.max(-1, Math.min(1, pan)),
            this.audioContext.currentTime + 0.1
          );
          
          // Vary frequency slightly based on distance (Doppler-like effect, subtle)
          const freqVariation = 1 - (distance / maxDistance) * 0.1;
          spatialSource.osc.frequency.linearRampToValueAtTime(
            (80 + Math.random() * 20) * freqVariation,
            this.audioContext.currentTime + 0.5
          );
        } else {
          // Fade out if too far
          spatialSource.gainNode.gain.linearRampToValueAtTime(
            0,
            this.audioContext.currentTime + 0.2
          );
        }
        
        spatialSource.lastUpdate = Date.now();
      }
      
      // Clean up old spatial sources
      cleanupSpatialSources() {
        const now = Date.now();
        const timeout = 2000; // Remove sources not updated in 2 seconds
        
        for (const [objectId, source] of this.spatialSources.entries()) {
          if (now - source.lastUpdate > timeout) {
            try {
              source.osc.stop();
              source.osc.disconnect();
              source.gainNode.disconnect();
              source.panner.disconnect();
            } catch (error) {
              // Ignore cleanup errors
            }
            this.spatialSources.delete(objectId);
          }
        }
      }
      
      setMasterVolume(value) {
        if (this.masterGain) {
          this.masterGain.gain.linearRampToValueAtTime(
            value,
            this.audioContext.currentTime + 0.1
          );
        }
      }
      
      setAmbientVolume(value) {
        if (this.ambientGain) {
          this.ambientGain.gain.linearRampToValueAtTime(
            value,
            this.audioContext.currentTime + 0.1
          );
        }
      }
      
      setCustomVolume(value) {
        if (this.customGain) {
          this.customGain.gain.linearRampToValueAtTime(
            value,
            this.audioContext.currentTime + 0.1
          );
        }
      }
      
      setSpatialVolume(value) {
        if (this.spatialGain) {
          this.spatialGain.gain.linearRampToValueAtTime(
            value,
            this.audioContext.currentTime + 0.1
          );
        }
      }
      
      start() {
        if (!this.isInitialized || this.isPlaying) return;
        
        // Resume audio context (required by browser policies)
        if (this.audioContext.state === 'suspended') {
          this.audioContext.resume();
        }
        
        this.isPlaying = true;
        
        if (this.ambientType !== 'off') {
          this.startAmbient();
        }
        
        if (this.customAudioElement) {
          this.playCustomAudio();
        }
      }
      
      stop() {
        if (!this.isPlaying) return;
        
        this.isPlaying = false;
        this.stopAmbient();
        this.stopCustomAudio();
        
        // Clean up all spatial sources
        for (const [objectId, source] of this.spatialSources.entries()) {
          try {
            source.osc.stop();
            source.osc.disconnect();
            source.gainNode.disconnect();
            source.panner.disconnect();
          } catch (error) {
            // Ignore cleanup errors
          }
        }
        this.spatialSources.clear();
      }
    }
    
    // Initialize audio system
    const audioSystem = new CelestialAudioSystem();
    
    // =============================================================================
    // THREE.JS SCENE SETUP
    // =============================================================================
    
    // Initialize Three.js scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000508);
    scene.fog = new THREE.FogExp2(0x000508, 0.00025);

    // Camera setup
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 20, 40);

    // Renderer with enhanced settings
    const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.8;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Post-processing setup (optional, with fallback)
    let composer = null;
    let usePostProcessing = false;

    try {
      if (typeof THREE.EffectComposer !== 'undefined' &&
          typeof THREE.RenderPass !== 'undefined' &&
          typeof THREE.UnrealBloomPass !== 'undefined') {
        composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        window.__bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,  // strength
          0.4,  // radius
          0.85  // threshold
        );
        composer.addPass(window.__bloomPass);
        usePostProcessing = true;
        console.log('‚ú® Post-processing enabled with bloom effect');
      } else {
        console.warn('‚ö†Ô∏è Post-processing libraries not loaded, using standard rendering');
      }
    } catch (error) {
      console.error('‚ùå Error setting up post-processing:', error);
      console.log('üìå Falling back to standard rendering');
      usePostProcessing = false;
    }

    
    // =============================================================================
    // VISUAL PRESETS (UI)
    // =============================================================================
    function applyVisualPreset(preset){
      // Safe defaults
      try{
        if (preset === 'wow'){
          renderer.toneMappingExposure = 1.05;
          if (window.__bloomPass){
            window.__bloomPass.strength = 2.0;
            window.__bloomPass.radius = 0.55;
            window.__bloomPass.threshold = 0.72;
          }
          scene.fog.density = 0.00022;
        } else if (preset === 'museum'){
          renderer.toneMappingExposure = 0.78;
          if (window.__bloomPass){
            window.__bloomPass.strength = 1.0;
            window.__bloomPass.radius = 0.35;
            window.__bloomPass.threshold = 0.88;
          }
          scene.fog.density = 0.00018;
        } else if (preset === 'nightride'){
          renderer.toneMappingExposure = 0.62;
          if (window.__bloomPass){
            window.__bloomPass.strength = 1.6;
            window.__bloomPass.radius = 0.45;
            window.__bloomPass.threshold = 0.80;
          }
          scene.fog.density = 0.00028;
        } else {
          // default
          renderer.toneMappingExposure = 0.8;
          if (window.__bloomPass){
            window.__bloomPass.strength = 1.5;
            window.__bloomPass.radius = 0.4;
            window.__bloomPass.threshold = 0.85;
          }
          scene.fog.density = 0.00025;
        }
      }catch(e){ /* ignore */ }
    }

    // Apply initial preset requested by UI
    applyVisualPreset(window.__uiPresetRequested || 'default');

    // React to UI preset changes
    window.addEventListener('ui:preset', (ev) => {
      applyVisualPreset(ev.detail || 'default');
    });


    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 300;

    // Lighting - dramatic setup
    const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
    scene.add(ambientLight);

    // Sun point light (will be positioned at sun)
    const sunLight = new THREE.PointLight(0xfff4e6, 3, 300);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;
    scene.add(sunLight);

    // Create colorful nebula clouds
    const nebulaGroups = [];
    const nebulaColors = [
      { color: 0x8844ff, pos: new THREE.Vector3(300, 200, -500) },
      { color: 0xff4488, pos: new THREE.Vector3(-400, -150, -600) },
      { color: 0x44ff88, pos: new THREE.Vector3(250, -300, -700) },
      { color: 0xff8844, pos: new THREE.Vector3(-300, 250, -550) }
    ];

    nebulaColors.forEach(nebulaData => {
      const nebulaGroup = new THREE.Group();
      for (let i = 0; i < 3; i++) {
        const size = 150 + Math.random() * 100;
        const nebulaGeometry = new THREE.SphereGeometry(size, 32, 32);
        const nebulaMaterial = new THREE.MeshBasicMaterial({
          color: nebulaData.color,
          transparent: true,
          opacity: 0.03 + Math.random() * 0.02,
          blending: THREE.AdditiveBlending
        });
        const nebulaMesh = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
        nebulaMesh.position.set(
          (Math.random() - 0.5) * 100,
          (Math.random() - 0.5) * 100,
          (Math.random() - 0.5) * 100
        );
        nebulaGroup.add(nebulaMesh);
      }
      nebulaGroup.position.copy(nebulaData.pos);
      scene.add(nebulaGroup);
      nebulaGroups.push(nebulaGroup);
    });

    // Space dust particles
    const dustCount = 1000;
    const dustGeometry = new THREE.BufferGeometry();
    const dustVertices = [];
    const dustVelocities = [];

    for (let i = 0; i < dustCount; i++) {
      dustVertices.push(
        (Math.random() - 0.5) * 200,
        (Math.random() - 0.5) * 200,
        (Math.random() - 0.5) * 200
      );
      dustVelocities.push(
        (Math.random() - 0.5) * 0.02,
        (Math.random() - 0.5) * 0.02,
        (Math.random() - 0.5) * 0.02
      );
    }

    dustGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dustVertices, 3));
    const dustMaterial = new THREE.PointsMaterial({
      color: 0xaaaaaa,
      size: 0.5,
      transparent: true,
      opacity: 0.4,
      sizeAttenuation: true,
      blending: THREE.AdditiveBlending
    });

    const spaceDust = new THREE.Points(dustGeometry, dustMaterial);
    scene.add(spaceDust);

    // Create skybox sphere with stars texture
    const skyboxGeometry = new THREE.SphereGeometry(1500, 64, 64);
    const starsTexture = new THREE.TextureLoader().load('StarsTexture.jpeg');
    const skyboxMaterial = new THREE.MeshBasicMaterial({
      map: starsTexture,
      side: THREE.BackSide, // Render on the inside of the sphere
      transparent: false,
      opacity: 1.0
    });
    const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
    scene.add(skybox);

    // Hand-drawn style materials
    const sunMaterial = createHandDrawnMaterial(0xffeb3b);
    const planetMaterial = (color) => createHandDrawnMaterial(color);

    // Load all planet textures
    const textureLoader = new THREE.TextureLoader();
    const planetTextures = {
      Mercury: textureLoader.load('mercury.jpg'),
      Venus: textureLoader.load('venus.jpg'),
      Earth: textureLoader.load('earth.jpeg'),
      Mars: textureLoader.load('mars.jpg'),
      Jupiter: textureLoader.load('jupiter.jpg'),
      Saturn: textureLoader.load('saturn.jpg'),
      Uranus: textureLoader.load('uranus.jpg'),
      Neptune: textureLoader.load('neptune.jpg'),
      Moon: textureLoader.load('moon.jpg')
    };
    
    // Load Saturn rings texture
    const saturnRingsTexture = textureLoader.load('SaturnRingsTexture.png');
    
    const orbitMaterial = new THREE.LineBasicMaterial({
      color: 0xa5a5a5,
      transparent: true,
      opacity: 0.7
    });

    function createHandDrawnMaterial(color) {
      return new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.8,
        metalness: 0.1,
        flatShading: true
      });
    }

    // Celestial bodies
    const bodies = [];

    // Spectacular Sun with multiple layers
    const sunGroup = new THREE.Group();

    // Core sun
    const sunGeometry = new THREE.SphereGeometry(3, 64, 64);
    const sunCoreMaterial = new THREE.MeshStandardMaterial({
      color: 0xffff00,
      emissive: 0xffff00,
      emissiveIntensity: 2,
      roughness: 1.0,
      metalness: 0.0
    });
    const sun = new THREE.Mesh(sunGeometry, sunCoreMaterial);
    sunGroup.add(sun);

    // Sun glow layer 1
    const sunGlow1Geometry = new THREE.SphereGeometry(3.3, 64, 64);
    const sunGlow1Material = new THREE.MeshBasicMaterial({
      color: 0xffaa00,
      transparent: true,
      opacity: 0.4,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide
    });
    const sunGlow1 = new THREE.Mesh(sunGlow1Geometry, sunGlow1Material);
    sunGroup.add(sunGlow1);

    // Sun glow layer 2 (corona)
    const sunGlow2Geometry = new THREE.SphereGeometry(4, 64, 64);
    const sunGlow2Material = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.2,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide
    });
    const sunGlow2 = new THREE.Mesh(sunGlow2Geometry, sunGlow2Material);
    sunGroup.add(sunGlow2);

    // Outer corona
    const sunGlow3Geometry = new THREE.SphereGeometry(5.5, 64, 64);
    const sunGlow3Material = new THREE.MeshBasicMaterial({
      color: 0xffdd88,
      transparent: true,
      opacity: 0.1,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide
    });
    const sunGlow3 = new THREE.Mesh(sunGlow3Geometry, sunGlow3Material);
    sunGroup.add(sunGlow3);

    scene.add(sunGroup);
    sunLight.position.set(0, 0, 0);

    bodies.push({
      obj: sun,
      group: sunGroup,
      glow1: sunGlow1,
      glow2: sunGlow2,
      glow3: sunGlow3,
      orbitRadius: 0,
      name: "Sun",
      speed: 0,
      selfRotationSpeed: 0.001
    });

    // Planets data with orbital elements
    const planetsData = [
      {name: "Mercury", radius: 0.4, semiMajorAxis: 7, speed: 0.04, color: 0xb97a56, tilt: 0.03, 
       eccentricity: 0.206, inclination: 7.0, moons: []},
      {name: "Venus", radius: 0.6, semiMajorAxis: 10, speed: 0.015, color: 0xe6c460, tilt: 177.4, 
       eccentricity: 0.007, inclination: 3.4, moons: []},
      {name: "Earth", radius: 0.7, semiMajorAxis: 15, speed: 0.01, color: 0x4a80f0, tilt: 23.5, 
       eccentricity: 0.017, inclination: 0, moons: [
        {name: "Moon", radius: 0.2, distance: 2.5, speed: 0.1, color: 0xcfcfcf}
      ]},
      {name: "Mars", radius: 0.5, semiMajorAxis: 20, speed: 0.008, color: 0xe2714b, tilt: 25.2, 
       eccentricity: 0.093, inclination: 1.85, moons: [
        {name: "Phobos", radius: 0.08, distance: 1.2, speed: 0.15, color: 0x9e7b60},
        {name: "Deimos", radius: 0.06, distance: 1.8, speed: 0.08, color: 0xa88c75}
      ]},
      {name: "Jupiter", radius: 1.3, semiMajorAxis: 30, speed: 0.002, color: 0xf0b78e, tilt: 3.1, 
       eccentricity: 0.049, inclination: 1.3, moons: [
        {name: "Io", radius: 0.25, distance: 2.2, speed: 0.12, color: 0xffcc66},
        {name: "Europa", radius: 0.22, distance: 2.8, speed: 0.09, color: 0xddeeff},
        {name: "Ganymede", radius: 0.3, distance: 3.5, speed: 0.06, color: 0xb0a090},
        {name: "Callisto", radius: 0.28, distance: 4.5, speed: 0.04, color: 0x8f7e6b}
      ]},
      {name: "Saturn", radius: 1.0, semiMajorAxis: 38, speed: 0.0009, color: 0xf0e078, tilt: 26.7, 
       eccentricity: 0.057, inclination: 2.5, moons: [
        {name: "Enceladus", radius: 0.1, distance: 1.8, speed: 0.12, color: 0xffffff},
        {name: "Titan", radius: 0.35, distance: 3.5, speed: 0.06, color: 0xe0c080}
      ]},
      {name: "Uranus", radius: 0.8, semiMajorAxis: 45, speed: 0.0004, color: 0x7ec7ed, tilt: 97.8, 
       eccentricity: 0.046, inclination: 0.77, moons: [
        {name: "Titania", radius: 0.15, distance: 2.2, speed: 0.08, color: 0xb0c4de},
        {name: "Oberon", radius: 0.14, distance: 2.8, speed: 0.06, color: 0xaaaaff}
      ]},
      {name: "Neptune", radius: 0.8, semiMajorAxis: 52, speed: 0.0001, color: 0x4b70dd, tilt: 28.3, 
       eccentricity: 0.011, inclination: 1.77, moons: [
        {name: "Triton", radius: 0.18, distance: 2.5, speed: 0.07, color: 0xc0d6e4}
      ]}
    ];

    // Ring systems data
    const ringSystemsData = {
      "Jupiter": {
        rings: [
          {innerRadius: 1.4, outerRadius: 1.5, opacity: 0.3, color: 0xcccccc}
        ]
      },
      "Saturn": {
        rings: [
          {innerRadius: 1.2, outerRadius: 1.5, opacity: 0.8, color: 0xf0e078},
          {innerRadius: 1.6, outerRadius: 2.0, opacity: 0.6, color: 0xe6d068},
          {innerRadius: 2.1, outerRadius: 2.3, opacity: 0.4, color: 0xf0e078}
        ]
      },
      "Uranus": {
        rings: [
          {innerRadius: 1.1, outerRadius: 1.2, opacity: 0.4, color: 0x7ec7ed},
          {innerRadius: 1.3, outerRadius: 1.4, opacity: 0.3, color: 0x6eaada}
        ]
      },
      "Neptune": {
        rings: [
          {innerRadius: 1.1, outerRadius: 1.3, opacity: 0.3, color: 0x4b70dd},
          {innerRadius: 1.4, outerRadius: 1.5, opacity: 0.2, color: 0x3b60cd}
        ]
      }
    };

    // Particle trail systems for planets
    const planetTrails = [];

    // Create planets
    planetsData.forEach(data => {
      const geometry = new THREE.SphereGeometry(data.radius, 32, 32);
      let material;
      // Use texture if available, otherwise use color
      if (planetTextures[data.name]) {
        material = new THREE.MeshStandardMaterial({
          map: planetTextures[data.name],
          metalness: 0.2,
          roughness: 0.8
        });
      } else {
        material = planetMaterial(data.color);
      }
      const planet = new THREE.Mesh(geometry, material);
      planet.castShadow = planet.receiveShadow = true;

      // Add atmospheric glow for planets with atmospheres
      const hasAtmosphere = ["Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"].includes(data.name);
      if (hasAtmosphere) {
        const glowGeometry = new THREE.SphereGeometry(data.radius * 1.15, 32, 32);
        let atmosphereColor;
        switch(data.name) {
          case "Earth": atmosphereColor = 0x6699ff; break;
          case "Venus": atmosphereColor = 0xe6c460; break;
          case "Mars": atmosphereColor = 0xe2714b; break;
          case "Jupiter": atmosphereColor = 0xf0b78e; break;
          case "Saturn": atmosphereColor = 0xf0e078; break;
          case "Uranus": atmosphereColor = 0x7ec7ed; break;
          case "Neptune": atmosphereColor = 0x4b70dd; break;
          default: atmosphereColor = 0x88aaff;
        }
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: atmosphereColor,
          transparent: true,
          opacity: 0.15,
          side: THREE.BackSide,
          blending: THREE.AdditiveBlending
        });
        const atmosphereGlow = new THREE.Mesh(glowGeometry, glowMaterial);
        planet.add(atmosphereGlow);
      }

      // Create particle trail for this planet
      const trailPositions = [];
      for (let i = 0; i < 100; i++) {
        trailPositions.push(0, 0, 0);
      }
      const trailGeometry = new THREE.BufferGeometry();
      trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
      const trailMaterial = new THREE.LineBasicMaterial({
        color: data.color,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });
      const trail = new THREE.Line(trailGeometry, trailMaterial);
      scene.add(trail);
      planetTrails.push({ trail: trail, positions: [], maxLength: 100 });

      // Calculate ellipse parameters
      const a = data.semiMajorAxis;
      const e = data.eccentricity;
      const b = a * Math.sqrt(1 - e * e); // semi-minor axis
      const c = a * e; // distance from center to focus

      // Create elliptical orbit path
      const orbitGeometry = new THREE.BufferGeometry();
      const points = [];

      for (let i = 0; i <= 128; i++) {
        const angle = (i / 128) * Math.PI * 2;
        // Ellipse centered at origin
        const x = a * Math.cos(angle);
        const z = b * Math.sin(angle);
        // Shift so Sun is at one focus
        points.push(new THREE.Vector3(x - c, 0, z));
      }

      orbitGeometry.setFromPoints(points);
      const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
      
      // Orbit group for inclination
      const orbitGroup = new THREE.Object3D();
      orbitGroup.rotation.x = THREE.MathUtils.degToRad(data.inclination);
      scene.add(orbitGroup);
      
      // Pivot group for orbital motion
      const pivot = new THREE.Object3D();
      pivot.position.x = -c; // Offset pivot to focus
      orbitGroup.add(pivot);
      orbitGroup.add(orbitLine);
      
      // Planet container for axial tilt
      const planetContainer = new THREE.Object3D();
      planetContainer.rotation.z = THREE.MathUtils.degToRad(data.tilt);
      pivot.add(planetContainer);
      planetContainer.add(planet);
      
      // Position planet at random starting angle on orbit
      const startAngle = Math.random() * Math.PI * 2;
      const x = a * Math.cos(startAngle);
      const z = b * Math.sin(startAngle);
      planetContainer.position.set(x, 0, z);

      // Add ring systems if applicable
      const planetRings = [];
      if (ringSystemsData[data.name]) {
        const ringSystem = ringSystemsData[data.name];
        ringSystem.rings.forEach(ringData => {
          const ringGeometry = new THREE.RingGeometry(
            ringData.innerRadius,
            ringData.outerRadius,
            128
          );
          
          // Use texture for Saturn rings, otherwise use color
          let ringMaterial;
          if (data.name === "Saturn") {
            ringMaterial = new THREE.MeshStandardMaterial({
              map: saturnRingsTexture,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: ringData.opacity,
              metalness: 0.3,
              roughness: 0.7
            });
          } else {
            ringMaterial = new THREE.MeshStandardMaterial({
              color: ringData.color,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: ringData.opacity,
              emissive: ringData.color,
              emissiveIntensity: 0.1,
              metalness: 0.3,
              roughness: 0.7
            });
          }
          
          const ring = new THREE.Mesh(ringGeometry, ringMaterial);
          ring.rotation.x = Math.PI / 2;
          planet.add(ring);
          planetRings.push({
            mesh: ring,
            baseOpacity: ringData.opacity,
            material: ringMaterial
          });
        });
      }

      const bodyIndex = bodies.length;
      bodies.push({
        pivot: pivot,
        obj: planet,
        container: planetContainer,
        speed: data.speed,
        selfRotationSpeed: 0.005,
        name: data.name,
        angle: startAngle, // Use the random starting angle
        semiMajorAxis: a,
        semiMinorAxis: b,
        eccentricity: e,
        focusOffset: c,
        trailIndex: planetTrails.length - 1,
        rings: planetRings
      });

      // Add moons for this planet
      if (data.moons && data.moons.length > 0) {
        data.moons.forEach(moonData => {
          const moonGeometry = new THREE.SphereGeometry(moonData.radius, 32, 32);
          let moonMaterial;
          // Use Moon texture for Earth's Moon
          if (data.name === "Earth" && moonData.name === "Moon") {
            moonMaterial = new THREE.MeshStandardMaterial({
              map: planetTextures.Moon,
              metalness: 0.1,
              roughness: 0.9
            });
          } else {
            moonMaterial = planetMaterial(moonData.color);
          }
          const moon = new THREE.Mesh(moonGeometry, moonMaterial);
          moon.castShadow = moon.receiveShadow = true;

          // Create moon orbit around planet
          const moonPivot = new THREE.Object3D();
          planet.add(moonPivot);
          moonPivot.add(moon);
          moon.position.set(moonData.distance, 0, 0);

          // Add moon orbit line
          const moonOrbitGeometry = new THREE.BufferGeometry();
          const moonOrbitPoints = [];
          for (let i = 0; i <= 32; i++) {
            const angle = (i / 32) * Math.PI * 2;
            moonOrbitPoints.push(new THREE.Vector3(
              Math.cos(angle) * moonData.distance, 0, Math.sin(angle) * moonData.distance
            ));
          }
          moonOrbitGeometry.setFromPoints(moonOrbitPoints);
          const moonOrbitLine = new THREE.Line(moonOrbitGeometry, new THREE.LineBasicMaterial({
            color: 0x555555,
            transparent: true,
            opacity: 0.3
          }));
          planet.add(moonOrbitLine);

          bodies.push({
            pivot: moonPivot,
            obj: moon,
            speed: moonData.speed,
            selfRotationSpeed: 0.005,
            name: moonData.name,
            isMoon: true
          });
        });
      }
    });

    // Function to create a classical communication satellite
    function createSatellite() {
      const satelliteGroup = new THREE.Group();

      // Main body (small box) - reduced size 10x
      const bodyGeometry = new THREE.BoxGeometry(0.004, 0.004, 0.006);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        metalness: 0.8,
        roughness: 0.2,
        emissive: 0x4488ff,
        emissiveIntensity: 0.3
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      satelliteGroup.add(body);

      // Solar panels (two wings) - reduced size 10x
      const panelGeometry = new THREE.BoxGeometry(0.012, 0.008, 0.0002);
      const panelMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a3a5a,
        metalness: 0.5,
        roughness: 0.3,
        emissive: 0x0088ff,
        emissiveIntensity: 0.2
      });

      // Left panel
      const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
      leftPanel.position.set(-0.008, 0, 0);
      satelliteGroup.add(leftPanel);

      // Right panel
      const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
      rightPanel.position.set(0.008, 0, 0);
      satelliteGroup.add(rightPanel);

      // Small antenna - reduced size 10x
      const antennaGeometry = new THREE.CylinderGeometry(0.0002, 0.0002, 0.003, 8);
      const antennaMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.9,
        roughness: 0.1
      });
      const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
      antenna.position.set(0, 0.0035, 0);
      satelliteGroup.add(antenna);

      return satelliteGroup;
    }

    // Starlink Satellite Constellation around Earth
    const starlinkSatellites = [];
    const starlinkGroup = new THREE.Group();

    // Find Earth in the bodies array
    const earthBody = bodies.find(b => b.name === "Earth");

    if (earthBody) {
      // Create multiple orbital rings
      const numRings = 6; // Number of orbital planes
      const satellitesPerRing = 20; // Satellites per ring
      const baseOrbitRadius = 1.05; // Starting orbit radius (visible distance from Earth)
      const orbitSpacing = 0.09; // Spacing between rings

      for (let ring = 0; ring < numRings; ring++) {
        const orbitRadius = baseOrbitRadius + (ring * orbitSpacing);
        const ringInclination = (ring * 180 / numRings) % 180; // Different inclinations

        for (let sat = 0; sat < satellitesPerRing; sat++) {
          const satellite = createSatellite();

          // Random starting position on orbit
          const startAngle = (sat / satellitesPerRing) * Math.PI * 2 + Math.random() * 0.2;

          // Position satellite on orbit
          const x = orbitRadius * Math.cos(startAngle);
          const z = orbitRadius * Math.sin(startAngle);
          satellite.position.set(x, 0, z);

          // Random rotation
          satellite.rotation.set(
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
          );

          // Create orbital ring container
          const orbitContainer = new THREE.Object3D();
          orbitContainer.rotation.x = THREE.MathUtils.degToRad(ringInclination);
          orbitContainer.add(satellite);

          // Add to Earth (so satellites follow Earth)
          earthBody.obj.add(orbitContainer);

          starlinkSatellites.push({
            mesh: satellite,
            orbitContainer: orbitContainer,
            orbitRadius: orbitRadius,
            angle: startAngle,
            speed: 0.02 + Math.random() * 0.01, // Vary orbital speeds slightly
            ring: ring
          });
        }
      }
    }

    // Satellite visibility state
    let satelliteVisibility = 'highly'; // 'highly' or 'slightly'

    // Function to create the placement plane helper
    function createPlacementPlane(angle) {
      // Remove existing plane helper if it exists
      if (placementPlaneHelper) {
        scene.remove(placementPlaneHelper);
        // Properly dispose of all geometries and materials in the group
        placementPlaneHelper.traverse((child) => {
          if (child.geometry) {
            child.geometry.dispose();
          }
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(material => material.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
      }

      // Create a large circular disc to represent the placement plane
      const planeRadius = 100; // Large enough to cover the solar system view
      const segments = 64;
      
      // Create a grid-like appearance
      const gridHelper = new THREE.Group();
      
      // Choose color based on plane angle for visual distinction
      let planeColor;
      switch(angle) {
        case 0:   planeColor = 0x00ffff; break; // Cyan for North-South
        case 90:  planeColor = 0xff00ff; break; // Magenta for East-West
        case 45:  planeColor = 0xffff00; break; // Yellow for 45¬∞ diagonal
        case 135: planeColor = 0x00ff00; break; // Green for 135¬∞ diagonal
        default:  planeColor = 0x00ffff;
      }
      
      // Main disc with improved visibility
      const discGeometry = new THREE.CircleGeometry(planeRadius, segments);
      const discMaterial = new THREE.MeshBasicMaterial({
        color: planeColor,
        transparent: true,
        opacity: 0.25,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const disc = new THREE.Mesh(discGeometry, discMaterial);
      gridHelper.add(disc);
      
      // Add grid lines for better visibility
      const gridLines = new THREE.Group();
      
      // Radial lines
      for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2;
        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(Math.cos(angle) * planeRadius, Math.sin(angle) * planeRadius, 0)
        ]);
        const lineMaterial = new THREE.LineBasicMaterial({
          color: planeColor,
          transparent: true,
          opacity: 0.5,
          linewidth: 2,
          depthWrite: false
        });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        gridLines.add(line);
      }
      
      // Circular rings
      for (let r = 20; r <= planeRadius; r += 20) {
        const ringGeometry = new THREE.RingGeometry(r - 0.1, r + 0.1, segments);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: planeColor,
          transparent: true,
          opacity: 0.4,
          side: THREE.DoubleSide,
          depthWrite: false
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        gridLines.add(ring);
      }
      
      gridHelper.add(gridLines);
      
      // Rotate the plane based on the selected angle
      // The CircleGeometry is created in the XY plane (default, with normal pointing in +Z direction)
      // We need to rotate it to match the raycasting plane normals
      
      if (angle === 0) {
        // North-South: XY plane (vertical, perpendicular to Z axis, normal = (0,0,1))
        // Default orientation is already XY plane, but we need it vertical
        // No rotation needed - keep it in XY plane facing Z
        gridHelper.rotation.set(0, 0, 0);
      } else if (angle === 90) {
        // East-West: YZ plane (vertical, perpendicular to X axis, normal = (1,0,0))
        // Rotate from XY plane to YZ plane - rotate 90¬∞ around Y axis
        gridHelper.rotation.y = Math.PI / 2;
      } else if (angle === 45) {
        // 45¬∞ diagonal (normal = (1,0,1).normalized())
        // Rotate 45¬∞ around Y axis from the XY plane
        gridHelper.rotation.y = Math.PI / 4;
      } else if (angle === 135) {
        // 135¬∞ diagonal (normal = (-1,0,1).normalized())
        // Rotate -45¬∞ around Y axis from the XY plane (or equivalently 315¬∞)
        gridHelper.rotation.y = -Math.PI / 4;
      }
      
      placementPlaneHelper = gridHelper;
      scene.add(placementPlaneHelper);
    }

    // Function to update placement plane visibility
    function updatePlacementPlaneVisibility() {
      if (freezeMode && placementPlaneHelper) {
        placementPlaneHelper.visible = true;
      } else if (placementPlaneHelper) {
        placementPlaneHelper.visible = false;
      }
    }

    // Function to update satellite visibility
    function updateSatelliteVisibility() {
      starlinkSatellites.forEach(sat => {
        if (satelliteVisibility === 'highly') {
          sat.mesh.scale.set(2.8, 2.8, 2.8); // Normal size for high visibility
          sat.mesh.children.forEach(child => {
            if (child.material && child.material.emissive) {
              // Standard emissive intensity
              if (child === sat.mesh.children[0]) { // body
                child.material.emissiveIntensity = 0.5;
              } else if (child.geometry instanceof THREE.BoxGeometry) { // panels
                child.material.emissiveIntensity = 0.25;
              }
            }
          });
        } else {
          sat.mesh.scale.set(1.3, 1.3, 1.3); // Much smaller for slight visibility
          sat.mesh.children.forEach(child => {
            if (child.material && child.material.emissive) {
              // Reduced emissive intensity
              if (child === sat.mesh.children[0]) { // body
                child.material.emissiveIntensity = 0.25;
              } else if (child.geometry instanceof THREE.BoxGeometry) { // panels
                child.material.emissiveIntensity = 0.15;
              }
            }
          });
        }
      });
    }

    // Initialize satellite visibility
    updateSatelliteVisibility();

    // Asteroid Belt (between Mars and Jupiter)
    const asteroidBelt = [];
    const asteroidCount = 800;
    const asteroidGroup = new THREE.Group();

    for (let i = 0; i < asteroidCount; i++) {
      const radius = 0.05 + Math.random() * 0.15;
      const geometry = new THREE.DodecahedronGeometry(radius, 0);
      const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color().setHSL(0.05 + Math.random() * 0.05, 0.3, 0.3 + Math.random() * 0.2),
        roughness: 0.9,
        metalness: 0.1
      });
      const asteroid = new THREE.Mesh(geometry, material);
      asteroid.castShadow = true;
      asteroid.receiveShadow = true;

      // Position in belt
      const angle = Math.random() * Math.PI * 2;
      const distance = 23 + Math.random() * 5; // Between Mars (20) and Jupiter (30)
      const height = (Math.random() - 0.5) * 1.5;

      asteroid.position.set(
        Math.cos(angle) * distance,
        height,
        Math.sin(angle) * distance
      );

      asteroid.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );

      asteroidGroup.add(asteroid);
      asteroidBelt.push({
        mesh: asteroid,
        rotationSpeed: {
          x: (Math.random() - 0.5) * 0.01,
          y: (Math.random() - 0.5) * 0.01,
          z: (Math.random() - 0.5) * 0.01
        },
        orbitSpeed: 0.005 + Math.random() * 0.003,
        distance: distance,
        angle: angle
      });
    }
    scene.add(asteroidGroup);

    // Create spectacular comets
    const comets = [];
    const cometCount = 2;

    for (let i = 0; i < cometCount; i++) {
      const cometGroup = new THREE.Group();

      // Comet nucleus
      const nucleusGeometry = new THREE.SphereGeometry(0.3, 16, 16);
      const nucleusMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        emissive: 0x4488ff,
        emissiveIntensity: 0.5,
        roughness: 0.9
      });
      const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
      cometGroup.add(nucleus);

      // Coma (glowing atmosphere around nucleus)
      const comaGeometry = new THREE.SphereGeometry(0.6, 16, 16);
      const comaMaterial = new THREE.MeshBasicMaterial({
        color: 0x88ccff,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });
      const coma = new THREE.Mesh(comaGeometry, comaMaterial);
      cometGroup.add(coma);

      // Particle tail
      const tailParticleCount = 300;
      const tailGeometry = new THREE.BufferGeometry();
      const tailPositions = [];
      const tailColors = [];
      const tailSizes = [];

      for (let j = 0; j < tailParticleCount; j++) {
        tailPositions.push(0, 0, 0);
        const color = new THREE.Color(0x88ccff);
        tailColors.push(color.r, color.g, color.b);
        tailSizes.push(Math.random() * 0.3 + 0.1);
      }

      tailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(tailPositions, 3));
      tailGeometry.setAttribute('color', new THREE.Float32BufferAttribute(tailColors, 3));
      tailGeometry.setAttribute('size', new THREE.Float32BufferAttribute(tailSizes, 1));

      const tailMaterial = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        transparent: true,
        opacity: 0.35,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
      });

      const tail = new THREE.Points(tailGeometry, tailMaterial);
      cometGroup.add(tail);

      scene.add(cometGroup);

      // Comet orbit parameters (highly elliptical)
      const semiMajorAxis = 60 + i * 20;
      const eccentricity = 0.7 + Math.random() * 0.2;
      const inclination = (Math.random() - 0.5) * 30;

      comets.push({
        group: cometGroup,
        nucleus: nucleus,
        coma: coma,
        tail: tail,
        tailPositions: tailPositions,
        speed: 0.002 + Math.random() * 0.001,
        angle: Math.random() * Math.PI * 2,
        semiMajorAxis: semiMajorAxis,
        eccentricity: eccentricity,
        inclination: inclination
      });
    }

    // Animation state
    let animationPaused = false;
    let speedFactor = 0.5;
    let selectedPlanet = null;
    let cameraAnimating = false;
    let cameraAnimationProgress = 0;
    let cameraStartPos = new THREE.Vector3();
    let cameraEndPos = new THREE.Vector3();
    let cameraStartTarget = new THREE.Vector3();
    let cameraEndTarget = new THREE.Vector3();

    // Freeze mode for asteroid placement
    let freezeMode = false;
    let userAsteroids = [];
    const MAX_USER_ASTEROIDS = 100; // Support more than 50
    const ESCAPE_DISTANCE = 400; // Distance at which asteroids are removed
    const G = 0.1; // Gravitational constant for simulation
    
    // Asteroid placement plane settings
    let placementPlaneAngle = 0; // Default: North-South (0 degrees)
    let placementPlaneHelper = null; // Visual representation of the placement plane

    // Populate planet selector
    const planetSelector = document.getElementById('planetSelector');
    // Filter to get only planets (not moons) and add them in order
    const planetsForSelector = bodies.filter(body => !body.isMoon);
    planetsForSelector.forEach(body => {
      if (body.name !== "Sun") {
        const option = document.createElement('option');
        option.value = body.name;
        option.textContent = body.name;
        planetSelector.appendChild(option);
      }
    });

    // Planet selector change handler
    planetSelector.addEventListener('change', (e) => {
      const planetName = e.target.value;
      const targetBody = bodies.find(b => b.name === planetName);
      
      if (!targetBody) return;
      
      // Store current camera position and target
      cameraStartPos.copy(camera.position);
      cameraStartTarget.copy(controls.target);
      
      // Calculate new camera position and target
      const targetPos = new THREE.Vector3();
      if (targetBody.container) {
        targetBody.container.getWorldPosition(targetPos);
      } else {
        targetBody.obj.getWorldPosition(targetPos);
      }
      
      if (planetName === "Sun") {
        // Reset to original view
        cameraEndPos.set(0, 20, 40);
        cameraEndTarget.set(0, 0, 0);
        selectedPlanet = null;
      } else {
        // Set camera to view from planet's perspective
        cameraEndTarget.copy(targetPos);
        
        // Calculate camera offset based on planet size
        const planetRadius = targetBody.obj.geometry.parameters.radius || 1;
        const offset = planetRadius * 5; // Distance from planet
        
        // Position camera offset from planet
        cameraEndPos.copy(targetPos);
        cameraEndPos.y += offset * 0.5;
        cameraEndPos.z += offset;
        
        selectedPlanet = targetBody;
      
          // Update focus card (UI layer)
          try {
            const moonsCount = (function(){
              // Count moons by scanning bodies that are moons and parent planet matches by name heuristic
              // (moons are added immediately after their planet; not perfect but good enough for UI)
              if (targetBody.name === "Sun") return "‚Äî";
              // Use planetsData if in scope
              if (typeof planetsData !== 'undefined') {
                const pd = planetsData.find(p => p.name === targetBody.name);
                if (pd && pd.moons) return String(pd.moons.length);
              }
              return "‚Äî";
            })();

            window.__setFocusCard({
              name: targetBody.name,
              fact: (targetBody.name === "Sun")
                ? "The star that lights everything. Try WOW preset ‚ú®"
                : "Tip: switch to Nerd mode for more controls üß†",
              orbit: targetBody.semiMajorAxis ? (targetBody.semiMajorAxis.toFixed(1) + " AU-ish") : "‚Äî",
              speed: (targetBody.speed !== undefined) ? targetBody.speed.toFixed(4) : "‚Äî",
              moons: moonsCount
            });

            window.__wireFocusButtons({
              onFollow: () => {
                // re-trigger current selection to re-animate camera (cheap 'follow' UX)
                const sel = document.getElementById('planetSelector');
                if (sel) sel.dispatchEvent(new Event('change'));
              },
              onReset: () => document.getElementById('resetView')?.click()
            });
          } catch (e) { /* ignore UI errors */ }

        }
        
        // Start animation
      cameraAnimating = true;
      cameraAnimationProgress = 0;
    });

    // =============================================================================
    // CLICK / TAP SELECTION (Raycasting) + Guided Tour
    // =============================================================================

    // Make planets/moons (and their rings/glows) selectable by clicking/tapping in the scene.
    const __raycaster = new THREE.Raycaster();
    

    // Museum-grade hover label + kid-friendly snap assist
    const __hoverEl = document.getElementById('hoverLabel');

    function __setHoverAt(clientX, clientY, text){
      if (!__hoverEl) return;
      if (!text){
        __hoverEl.classList.remove('show');
        __hoverEl.style.transform = 'translate(-9999px,-9999px)';
        return;
      }
      __hoverEl.textContent = text;
      const pad = 14;
      const w = __hoverEl.offsetWidth || 120;
      const h = __hoverEl.offsetHeight || 24;
      const x = Math.min(window.innerWidth - w - pad, Math.max(pad, clientX + 12));
      const y = Math.min(window.innerHeight - h - pad, Math.max(pad, clientY + 12));
      __hoverEl.style.transform = `translate(${x}px, ${y}px)`;
      __hoverEl.classList.add('show');
    }

    // Snap assist: when a tap misses the mesh, select nearest body (screen-space)
    function __snapNearestBody(clientX, clientY){
      const rect = renderer.domElement.getBoundingClientRect();
      const px = clientX - rect.left;
      const py = clientY - rect.top;

      // Build unique body list from selectables
      const bodies = [];
      const seen = new Set();
      for (const obj of __selectables){
        const b = obj?.userData?.__bodyRef;
        if (b && !seen.has(b)){
          seen.add(b);
          bodies.push(b);
        }
      }
      if (bodies.length === 0) return null;

      const v = new THREE.Vector3();
      let best = null;
      let bestD2 = Infinity;

      // Threshold: generous on small screens / touch
      const base = Math.min(rect.width, rect.height);
      const isCoarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
      const thresh = isCoarse ? Math.max(34, base * 0.06) : Math.max(18, base * 0.035);
      const thresh2 = thresh * thresh;

      for (const b of bodies){
        if (!b?.obj) continue;
        b.obj.getWorldPosition(v);
        v.project(camera);
        // offscreen or behind camera
        if (v.z < -1 || v.z > 1) continue;

        const sx = (v.x * 0.5 + 0.5) * rect.width;
        const sy = (-v.y * 0.5 + 0.5) * rect.height;

        const dx = sx - px;
        const dy = sy - py;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2){
          bestD2 = d2;
          best = b;
        }
      }
      return (bestD2 <= thresh2) ? best : null;
    }

    // Hover labels
    renderer.domElement.addEventListener('pointermove', (evt) => {
      // Avoid hover labels while placing asteroids
      if (typeof freezeMode !== 'undefined' && freezeMode) {
        __setHoverAt(0,0,"");
        return;
      }
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ( (evt.clientX - rect.left) / rect.width ) * 2 - 1;
      const y = -( (evt.clientY - rect.top) / rect.height ) * 2 + 1;

      __pointer.set(x, y);
      __raycaster.setFromCamera(__pointer, camera);
      const hits = __raycaster.intersectObjects(__selectables, true);
      if (hits && hits.length){
        const body = hits[0].object?.userData?.__bodyRef;
        if (body && body.name){
          __setHoverAt(evt.clientX, evt.clientY, body.name);
          return;
        }
      }
      // No direct hit: try "near" assist for labels (smaller radius than selection)
      const near = __snapNearestBody(evt.clientX, evt.clientY);
      if (near && near.name){
        __setHoverAt(evt.clientX, evt.clientY, near.name);
      } else {
        __setHoverAt(0,0,"");
      }
    }, { passive: true });

    renderer.domElement.addEventListener('pointerleave', () => __setHoverAt(0,0,""), { passive: true });

    // Tap-to-focus with snap assist (does not trigger on drags)
    (function(){
      let __downX = 0, __downY = 0, __downT = 0;
      renderer.domElement.addEventListener('pointerdown', (e) => {
        __downX = e.clientX; __downY = e.clientY; __downT = performance.now();
      }, { passive: true });

      renderer.domElement.addEventListener('pointerup', (e) => {
        if (typeof freezeMode !== 'undefined' && freezeMode) return;
        // Respect your existing onCanvasPointer focus logic if it already hit something:
        // Only run snap if the raycast misses.
        const dt = performance.now() - __downT;
        const dx = e.clientX - __downX;
        const dy = e.clientY - __downY;
        if ((dx*dx + dy*dy) > 49) return; // orbit drag
        if (dt > 650) return; // long press ignore

        // Try a raycast pick first (same as __onCanvasPointer, but without side effects)
        const rect = renderer.domElement.getBoundingClientRect();
        const nx = ( (e.clientX - rect.left) / rect.width ) * 2 - 1;
        const ny = -( (e.clientY - rect.top) / rect.height ) * 2 + 1;
        __pointer.set(nx, ny);
        __raycaster.setFromCamera(__pointer, camera);
        const hits = __raycaster.intersectObjects(__selectables, true);
        const body = (hits && hits.length) ? hits[0].object?.userData?.__bodyRef : null;
        if (!body){
          const snapped = __snapNearestBody(e.clientX, e.clientY);
          if (snapped) __focusBody(snapped);
        }
      }, { passive: true });
    })();

const __pointer = new THREE.Vector2();
    const __selectables = [];

    function __tagSelectable(mesh, bodyRef){
      if (!mesh || !mesh.isObject3D) return;
      mesh.userData.__bodyRef = bodyRef;
      if (mesh.isMesh) __selectables.push(mesh);
      mesh.traverse?.((child)=>{
        if (child && child.isMesh){
          child.userData.__bodyRef = bodyRef;
          __selectables.push(child);
        }
      });
    }

    // Tag all bodies (Sun + planets + moons + rings + glow shells)
    try {
      bodies.forEach(b => __tagSelectable(b.obj, b));
    } catch(e){ /* ignore */ }

    function __worldPosOfBody(body){
      const p = new THREE.Vector3();
      if (body?.container) body.container.getWorldPosition(p);
      else body?.obj?.getWorldPosition(p);
      return p;
    }

    function __showFocusForBody(body){
      if (!body) return;
      try {
        const moonsCount = (function(){
          if (body.name === "Sun") return "‚Äî";
          if (typeof planetsData !== 'undefined') {
            const pd = planetsData.find(p => p.name === body.name);
            if (pd && pd.moons) return String(pd.moons.length);
          }
          // If it's a moon, say "Moon"
          if (body.isMoon) return "0";
          return "‚Äî";
        })();

        const fact = body.isMoon
          ? "A moon! Try zooming in and orbiting around it üåô"
          : (body.name === "Sun"
              ? "The star that lights everything. Try WOW preset ‚ú®"
              : "Tip: switch to Nerd mode for more controls üß†");

        window.__setFocusCard({
          name: body.name,
          fact,
          orbit: body.semiMajorAxis ? (body.semiMajorAxis.toFixed(1) + " AU-ish") : (body.isMoon ? "Orbiting its planet" : "‚Äî"),
          speed: (body.speed !== undefined) ? body.speed.toFixed(4) : "‚Äî",
          moons: moonsCount
        });

        window.__wireFocusButtons({
          onFollow: () => __focusBody(body),
          onReset: () => document.getElementById('resetView')?.click()
        });
      } catch(e){ /* ignore */ }
    }

    function __animateCameraTo(targetPos, radius=1){
      // Store current camera position and target
      cameraStartPos.copy(camera.position);
      cameraStartTarget.copy(controls.target);

      cameraEndTarget.copy(targetPos);

      const offset = Math.max(1.5, radius * 6);
      cameraEndPos.copy(targetPos);
      cameraEndPos.y += offset * 0.55;
      cameraEndPos.z += offset;

      cameraAnimating = true;
      cameraAnimationProgress = 0;
    }

    function __focusBody(body){
      if (!body) return;

      // If it‚Äôs a planet or Sun, reuse the existing selector workflow (keeps your current UX consistent)
      const sel = document.getElementById('planetSelector');
      if (sel && !body.isMoon) {
        sel.value = body.name;
        sel.dispatchEvent(new Event('change'));
        return;
      }

      // Otherwise, focus directly (e.g., moons)
      const p = __worldPosOfBody(body);
      const r = body?.obj?.geometry?.parameters?.radius || 0.3;
      selectedPlanet = body;
      __animateCameraTo(p, r);
      __showFocusForBody(body);
    }

    function __isClickOnUI(evt){
      const t = evt.target;
      if (!t) return false;
      return !!t.closest?.('#topBar, #controls, #audioControls, #focusCard, #tourOverlay');
    }

    function __onCanvasPointer(evt){
      if (typeof freezeMode !== "undefined" && freezeMode) return;
if (__isClickOnUI(evt)) return;
      if (!renderer?.domElement) return;

      const rect = renderer.domElement.getBoundingClientRect();
      const x = ( (evt.clientX - rect.left) / rect.width ) * 2 - 1;
      const y = -( (evt.clientY - rect.top) / rect.height ) * 2 + 1;

      __pointer.set(x, y);
      __raycaster.setFromCamera(__pointer, camera);

      const hits = __raycaster.intersectObjects(__selectables, true);
      if (!hits || hits.length === 0) return;

      const hit = hits[0].object;
      const body = hit?.userData?.__bodyRef;
      if (!body) return;

      // Ignore clicks on orbit lines/trails if any ever end up in selectables
      if (!body.name) return;

      __focusBody(body);
    }

    // Pointer down (works on mouse + touch)
    renderer.domElement.addEventListener('pointerdown', __onCanvasPointer, {passive:true});

    // =============================================================================
    // GUIDED TOUR (kid-friendly, short, skippable)
    // =============================================================================
    (function(){
      const overlay = document.getElementById('tourOverlay');
      const spot = document.getElementById('tourSpot');
      const card = document.getElementById('tourCard');
      const title = document.getElementById('tourTitle');
      const body = document.getElementById('tourBody');
      const stepTxt = document.getElementById('tourStep');
      const btnNext = document.getElementById('tourNext');
      const btnBack = document.getElementById('tourBack');
      const btnSkip = document.getElementById('tourSkip');
      const btnTour = document.getElementById('tourBtn');

      if (!overlay || !spot || !card || !title || !body || !btnNext || !btnBack || !btnSkip || !btnTour) return;

      const steps = [
        { el: '#topBar', t: 'Welcome', b: 'This is a toy solar system you can explore. Let‚Äôs do 5 quick ‚Äúwow‚Äù moves.' },
        { el: 'canvas', t: 'Orbit the camera', b: 'Drag to orbit. Pinch / scroll to zoom. (You can do this during the whole tour.)' },
        { el: '#planetSelector', t: 'Pick a planet', b: 'Choose a planet‚Ä¶ or just tap a planet in space. Try Earth üåç.' },
        { el: '#presetSelect', t: 'Make it spectacular', b: 'Switch to ‚ÄúWOW‚Äù for extra glow. You can always come back to ‚ÄúMuseum‚Äù.' },
        { el: '#toggleFreeze', t: 'Space rocks!', b: 'Freeze time to place asteroids. Unfreeze to watch them fly.' },
        { el: '#soundQuickToggle', t: 'Sound Lab', b: 'Open Sound Lab and try a soundscape. (Some browsers require a tap to start audio.)' },
        { el: '#focusCard', t: 'Focus card', b: 'When you focus a planet, you get a little info card. Use Follow for cinematic vibes.' },
      ];
      let i = 0;

      function rectFor(sel){
        if (sel === 'canvas') return renderer.domElement.getBoundingClientRect();
        const el = document.querySelector(sel);
        return el ? el.getBoundingClientRect() : null;
      }
      function place(sel){
        const r = rectFor(sel);
        const pad = 8;
        const vw = window.innerWidth, vh = window.innerHeight;

        if (!r){
          spot.style.display = 'none';
          card.style.left = (vw/2 - 160) + 'px';
          card.style.top = (vh/2 - 90) + 'px';
          return;
        }

        spot.style.display = 'block';
        const left = Math.max(10, r.left - pad);
        const top = Math.max(10, r.top - pad);
        const width = Math.min(vw - 20, r.width + pad*2);
        const height = Math.min(vh - 20, r.height + pad*2);

        spot.style.left = left + 'px';
        spot.style.top = top + 'px';
        spot.style.width = width + 'px';
        spot.style.height = height + 'px';

        // Put card near spotlight (prefer above, else below)
        const cardW = card.offsetWidth || 340;
        const cardH = card.offsetHeight || 160;
        let cx = left + Math.min(width - cardW, 0) + 0;
        cx = Math.min(vw - cardW - 12, Math.max(12, left));
        let cy = top - cardH - 12;
        if (cy < 12) cy = top + height + 12;
        if (cy + cardH > vh - 12) cy = vh - cardH - 12;

        card.style.left = cx + 'px';
        card.style.top = cy + 'px';
      }

      function render(){
        const s = steps[i];
        title.textContent = s.t;
        body.textContent = s.b;
        stepTxt.textContent = `${i+1}/${steps.length}`;
        btnBack.disabled = (i === 0);
        btnNext.textContent = (i === steps.length - 1) ? 'Done ‚úÖ' : 'Next ‚ñ∂';
        place(s.el);

        // Small ‚Äúassist‚Äù actions per-step
        if (s.el === '#presetSelect'){
          // Nudge preset to WOW in kid mode if user hasn't tried it yet
          // (non-destructive: only auto-set once)
          try {
            const key = 'tourPresetNudge';
            if (!localStorage.getItem(key)){
              const ps = document.getElementById('presetSelect');
              if (ps && ps.value === 'default'){
                ps.value = 'wow';
                ps.dispatchEvent(new Event('change'));
              }
              localStorage.setItem(key, '1');
            }
          } catch(e){}
        }
      }

      function open(){
        overlay.style.display = 'block';
        i = 0;
        render();
      }
      function close(){
        overlay.style.display = 'none';
        try { localStorage.setItem('tourSeen', '1'); } catch(e){}
      }

      btnTour.addEventListener('click', open);
      btnSkip.addEventListener('click', close);
      btnBack.addEventListener('click', ()=>{ if (i>0){ i--; render(); }});
      btnNext.addEventListener('click', ()=>{
        if (i < steps.length - 1){ i++; render(); }
        else close();
      });

      window.addEventListener('resize', ()=>{ if (overlay.style.display==='block') render(); });

      // Auto-suggest once per device
      try {
        if (!localStorage.getItem('tourSeen')){
          // show a subtle hint by briefly flashing the Tour button
          setTimeout(()=>{
            btnTour.animate?.([{transform:'scale(1)'},{transform:'scale(1.08)'},{transform:'scale(1)'}], {duration:900});
          }, 900);
        }
      } catch(e){}
    })();


    // Controls
    document.getElementById('toggleAnimation').addEventListener('click', () => {
      animationPaused = !animationPaused;
      document.getElementById('toggleAnimation').textContent = animationPaused ? "Play" : "Pause";
    });

    document.getElementById('toggleFreeze').addEventListener('click', () => {
      freezeMode = !freezeMode;
      document.getElementById('toggleFreeze').textContent = freezeMode ? "Unfreeze" : "Freeze (Place Asteroids)";
      const planeSelectorDiv = document.getElementById('planeSelector');
      
      if (freezeMode) {
        animationPaused = true;
        document.getElementById('toggleAnimation').textContent = "Play";
        document.getElementById('toggleAnimation').disabled = true;
        renderer.domElement.style.cursor = 'crosshair';
        
        // Show plane selector
        planeSelectorDiv.style.display = 'block';
        
        // Create the placement plane with current angle
        createPlacementPlane(placementPlaneAngle);
        updatePlacementPlaneVisibility();
      } else {
        // Automatically resume simulation when unfreezing
        animationPaused = false;
        document.getElementById('toggleAnimation').textContent = "Pause";
        document.getElementById('toggleAnimation').disabled = false;
        renderer.domElement.style.cursor = 'default';
        
        // Hide plane selector
        planeSelectorDiv.style.display = 'none';
        
        // Hide the placement plane
        updatePlacementPlaneVisibility();
      }
    });

    document.getElementById('resetView').addEventListener('click', () => {
      camera.position.set(0, 20, 40);
      controls.target.set(0, 0, 0);
      controls.reset();
      selectedPlanet = null;
      planetSelector.value = "Sun";
    });

    document.getElementById('speedControl').addEventListener('input', (e) => {
      speedFactor = parseFloat(e.target.value);
    });

    document.getElementById('toggleSatellites').addEventListener('click', () => {
      satelliteVisibility = satelliteVisibility === 'highly' ? 'slightly' : 'highly';
      document.getElementById('toggleSatellites').textContent =
        `Satellites: ${satelliteVisibility === 'highly' ? 'Highly' : 'Slightly'} Visible`;
      updateSatelliteVisibility();
    });

    // Plane selector change handler
    document.getElementById('planeSelect').addEventListener('change', (e) => {
      placementPlaneAngle = parseFloat(e.target.value);
      if (freezeMode) {
        createPlacementPlane(placementPlaneAngle);
        updatePlacementPlaneVisibility();
      }
    });

    // =============================================================================
    // AUDIO CONTROLS
    // =============================================================================
    
    // Toggle audio on/off
    document.getElementById('toggleAudio').addEventListener('click', async () => {
      const btn = document.getElementById('toggleAudio');
      
      if (!audioSystem.isInitialized) {
        await audioSystem.initialize();
      }
      
      if (audioSystem.isPlaying) {
        audioSystem.stop();
        btn.textContent = 'Start Audio';
      } else {
        audioSystem.start();
        btn.textContent = 'Stop Audio';
      }
    });
    
    // Master volume control
    document.getElementById('masterVolume').addEventListener('input', (e) => {
      const volume = parseFloat(e.target.value) / 100;
      audioSystem.setMasterVolume(volume);
    });
    
    // Ambient type selector
    document.getElementById('ambientType').addEventListener('change', (e) => {
      audioSystem.setAmbientType(e.target.value);
    });
    
    // Ambient volume control
    document.getElementById('ambientVolume').addEventListener('input', (e) => {
      const volume = parseFloat(e.target.value) / 100;
      audioSystem.setAmbientVolume(volume);
    });
    
    // Custom audio file upload
    document.getElementById('customAudioFile').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        audioSystem.loadCustomAudio(file);
      }
    });
    
    // Custom audio volume control
    document.getElementById('customVolume').addEventListener('input', (e) => {
      const volume = parseFloat(e.target.value) / 100;
      audioSystem.setCustomVolume(volume);
    });
    
    // Spatial audio enable/disable
    document.getElementById('spatialAudioEnabled').addEventListener('change', (e) => {
      audioSystem.spatialEnabled = e.target.checked;
    });
    
    // Spatial audio volume control
    document.getElementById('spatialVolume').addEventListener('input', (e) => {
      const volume = parseFloat(e.target.value) / 100;
      audioSystem.setSpatialVolume(volume);
    });

    // Touch tracking for mobile devices
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    const TAP_THRESHOLD = 10; // pixels - maximum movement to be considered a tap
    const TAP_TIME_THRESHOLD = 300; // milliseconds - maximum duration to be considered a tap

    // Click/Touch handler for placing asteroids
    function onCanvasClick(event) {
      if (!freezeMode || userAsteroids.length >= MAX_USER_ASTEROIDS) return;

      // Calculate position in normalized device coordinates
      const mouse = new THREE.Vector2();
      
      // Handle both mouse and touch events
      if (event.touches && event.touches.length > 0) {
        // Touch event
        mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
      } else if (event.changedTouches && event.changedTouches.length > 0) {
        // Touch end event
        mouse.x = (event.changedTouches[0].clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.changedTouches[0].clientY / window.innerHeight) * 2 + 1;
      } else {
        // Mouse event
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      // Raycast to find position in 3D space
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Create the appropriate plane based on the selected angle
      let plane;
      
      if (placementPlaneAngle === 0) {
        // North-South: XY plane (vertical plane facing Z)
        plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      } else if (placementPlaneAngle === 90) {
        // East-West: YZ plane (vertical plane facing X)
        plane = new THREE.Plane(new THREE.Vector3(1, 0, 0), 0);
      } else if (placementPlaneAngle === 45) {
        // 45¬∞ diagonal: rotated plane
        const normal = new THREE.Vector3(1, 0, 1).normalize();
        plane = new THREE.Plane(normal, 0);
      } else if (placementPlaneAngle === 135) {
        // 135¬∞ diagonal (270¬∞ from problem statement): rotated plane
        const normal = new THREE.Vector3(-1, 0, 1).normalize();
        plane = new THREE.Plane(normal, 0);
      } else {
        // Fallback to horizontal plane
        plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      }
      
      const intersection = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersection);

      if (intersection) {
        createUserAsteroid(intersection);
      }
    }

    // Handle touch start - track initial position
    function onTouchStart(event) {
      if (!freezeMode) return;
      
      if (event.touches && event.touches.length === 1) {
        touchStartX = event.touches[0].clientX;
        touchStartY = event.touches[0].clientY;
        touchStartTime = Date.now();
      }
    }

    // Handle touch end - check if it was a tap and place asteroid
    function onTouchEnd(event) {
      if (!freezeMode || userAsteroids.length >= MAX_USER_ASTEROIDS) return;
      
      if (event.changedTouches && event.changedTouches.length === 1) {
        const touchEndX = event.changedTouches[0].clientX;
        const touchEndY = event.changedTouches[0].clientY;
        const touchEndTime = Date.now();
        
        // Calculate movement distance
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const duration = touchEndTime - touchStartTime;
        
        // Check if it was a tap (minimal movement and quick)
        if (distance < TAP_THRESHOLD && duration < TAP_TIME_THRESHOLD) {
          // Prevent default to avoid triggering click event as well
          event.preventDefault();
          // Place asteroid at tap position
          onCanvasClick(event);
        }
      }
    }

    function createUserAsteroid(position) {
      // Create asteroid mesh
      const radius = 0.2 + Math.random() * 0.2;
      const geometry = new THREE.DodecahedronGeometry(radius, 0);
      // Bright cyan color to distinguish from asteroid belt (brown/gray)
      const material = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        roughness: 0.7,
        metalness: 0.3,
        emissive: 0x00ccff,
        emissiveIntensity: 0.8
      });
      const asteroid = new THREE.Mesh(geometry, material);
      asteroid.castShadow = true;
      asteroid.receiveShadow = true;
      asteroid.position.copy(position);

      // Random rotation
      asteroid.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );

      scene.add(asteroid);

      // Create trajectory trail for this asteroid
      const trailPositions = [];
      for (let i = 0; i < 150; i++) {
        trailPositions.push(position.x, position.y, position.z);
      }
      const trailGeometry = new THREE.BufferGeometry();
      trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
      const trailMaterial = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
        linewidth: 2,
        depthWrite: false
      });
      const trail = new THREE.Line(trailGeometry, trailMaterial);
      scene.add(trail);

      // Calculate initial velocity toward the Sun with some randomness
      const directionToSun = new THREE.Vector3(0, 0, 0).sub(position).normalize();

      // Add some bias toward the Sun but with variation (reduced 10x for more realistic speeds)
      const speed = 0.01 + Math.random() * 0.01;
      const velocity = directionToSun.multiplyScalar(speed);

      // Add some perpendicular velocity for more interesting trajectories
      const perpendicular = new THREE.Vector3(-directionToSun.z, 0, directionToSun.x);
      velocity.add(perpendicular.multiplyScalar((Math.random() - 0.5) * 0.01));

      // Store asteroid data
      userAsteroids.push({
        mesh: asteroid,
        velocity: velocity,
        mass: radius * radius * radius, // Mass proportional to volume
        radius: radius,
        rotationSpeed: {
          x: (Math.random() - 0.5) * 0.05,
          y: (Math.random() - 0.5) * 0.05,
          z: (Math.random() - 0.5) * 0.05
        },
        trail: trail,
        trailPositions: [position.clone()],
        maxTrailLength: 150
      });
    }

    // Add click listener for desktop
    renderer.domElement.addEventListener('click', onCanvasClick);
    
    // Add touch listeners for mobile devices
    renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: true });
    renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });

    // Labels
    function updateLabels() {
      // Remove existing labels
      document.querySelectorAll('.planet-label').forEach(el => el.remove());

      // Add labels for each planet
      bodies.forEach(body => {
        if (!body.name || body.isMoon) return; // Skip moon labels to avoid clutter

        const position = new THREE.Vector3();
        if (body.container) {
          body.container.getWorldPosition(position);
        } else {
          body.obj.getWorldPosition(position);
        }

        position.project(camera);

        // Only show label if the planet is in front of the camera and within viewport
        // position.z > 1 means behind the camera
        // Check if within screen bounds with some margin
        if (position.z > 1 || 
            position.x < -1.2 || position.x > 1.2 || 
            position.y < -1.2 || position.y > 1.2) {
          return; // Planet is not visible, skip label
        }

        const x = (position.x * 0.5 + 0.5) * window.innerWidth;
        const y = (position.y * -0.5 + 0.5) * window.innerHeight;

        const label = document.createElement('div');
        label.className = 'planet-label';
        label.textContent = body.name;
        label.style.left = `${x}px`;
        label.style.top = `${y}px`;

        document.body.appendChild(label);
      });
    }

    // Animation loop
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;

      // Animate sun pulsing glow
      const sunBody = bodies.find(b => b.name === "Sun");
      if (sunBody) {
        const pulse = Math.sin(time * 2) * 0.1 + 1;
        sunBody.glow1.scale.set(pulse, pulse, pulse);
        sunBody.glow2.scale.set(pulse * 0.95, pulse * 0.95, pulse * 0.95);
        sunBody.glow3.scale.set(pulse * 0.9, pulse * 0.9, pulse * 0.9);

        // Pulse sun light intensity
        sunLight.intensity = 3 + Math.sin(time * 2) * 0.3;
      }

      // Rotate skybox slowly with the simulation
      if (!animationPaused) {
        skybox.rotation.y += 0.00005 * speedFactor;
      }

      // Slowly rotate nebula clouds
      nebulaGroups.forEach((group, i) => {
        group.rotation.x += 0.0001 * (i % 2 === 0 ? 1 : -1);
        group.rotation.y += 0.0002 * (i % 2 === 0 ? 1 : -1);
      });

      // Animate space dust
      const dustPositions = dustGeometry.attributes.position.array;
      for (let i = 0; i < dustCount; i++) {
        const idx = i * 3;
        dustPositions[idx] += dustVelocities[idx];
        dustPositions[idx + 1] += dustVelocities[idx + 1];
        dustPositions[idx + 2] += dustVelocities[idx + 2];

        // Wrap around
        if (Math.abs(dustPositions[idx]) > 100) dustPositions[idx] *= -1;
        if (Math.abs(dustPositions[idx + 1]) > 100) dustPositions[idx + 1] *= -1;
        if (Math.abs(dustPositions[idx + 2]) > 100) dustPositions[idx + 2] *= -1;
      }
      dustGeometry.attributes.position.needsUpdate = true;

      // Handle camera animation
      if (cameraAnimating) {
        cameraAnimationProgress += 0.02;

        if (cameraAnimationProgress >= 1) {
          cameraAnimationProgress = 1;
          cameraAnimating = false;
        }

        // Smooth easing function
        const t = cameraAnimationProgress;
        const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

        // Interpolate camera position
        camera.position.lerpVectors(cameraStartPos, cameraEndPos, eased);
        controls.target.lerpVectors(cameraStartTarget, cameraEndTarget, eased);
      }

      // Update controls target to follow selected planet
      if (selectedPlanet && !cameraAnimating) {
        const targetPos = new THREE.Vector3();
        if (selectedPlanet.container) {
          selectedPlanet.container.getWorldPosition(targetPos);
        } else {
          selectedPlanet.obj.getWorldPosition(targetPos);
        }
        controls.target.copy(targetPos);
      }

      if (!animationPaused) {
        // Animate asteroids
        asteroidBelt.forEach(asteroid => {
          // Rotate asteroids
          asteroid.mesh.rotation.x += asteroid.rotationSpeed.x * speedFactor;
          asteroid.mesh.rotation.y += asteroid.rotationSpeed.y * speedFactor;
          asteroid.mesh.rotation.z += asteroid.rotationSpeed.z * speedFactor;

          // Orbit asteroids
          asteroid.angle += asteroid.orbitSpeed * speedFactor;
          const x = Math.cos(asteroid.angle) * asteroid.distance;
          const z = Math.sin(asteroid.angle) * asteroid.distance;
          asteroid.mesh.position.x = x;
          asteroid.mesh.position.z = z;
        });

        // Animate comets
        comets.forEach(comet => {
          comet.angle += comet.speed * speedFactor;

          // Calculate elliptical orbit position
          const a = comet.semiMajorAxis;
          const e = comet.eccentricity;
          const b = a * Math.sqrt(1 - e * e);
          const c = a * e;

          const x = a * Math.cos(comet.angle) - c;
          const y = Math.sin(comet.angle * 0.5) * Math.sin(THREE.MathUtils.degToRad(comet.inclination)) * a * 0.3;
          const z = b * Math.sin(comet.angle);

          comet.group.position.set(x, y, z);

          // Update tail particles
          const positions = comet.tail.geometry.attributes.position.array;
          const cometPos = new THREE.Vector3(x, y, z);
          const sunPos = new THREE.Vector3(0, 0, 0);
          const tailDirection = new THREE.Vector3().subVectors(cometPos, sunPos).normalize();

          for (let i = 0; i < 300; i++) {
            const idx = i * 3;
            const spread = (Math.random() - 0.5) * 1.5;
            const length = i * 0.2;
            positions[idx] = tailDirection.x * length + spread;
            positions[idx + 1] = tailDirection.y * length + spread;
            positions[idx + 2] = tailDirection.z * length + spread;
          }
          comet.tail.geometry.attributes.position.needsUpdate = true;

          // Pulse coma
          const comaPulse = Math.sin(time * 3) * 0.2 + 1;
          comet.coma.scale.set(comaPulse, comaPulse, comaPulse);
        });

        // Animate celestial bodies
        bodies.forEach((body, index) => {
          if (body.isMoon) {
            // Moons keep simple circular motion
            body.pivot.rotation.y += body.speed * speedFactor;
          } else if (body.eccentricity !== undefined) {
            // Planets use elliptical motion with variable speed
            body.angle += body.speed * speedFactor;

            // Calculate position on ellipse
            const x = body.semiMajorAxis * Math.cos(body.angle);
            const z = body.semiMinorAxis * Math.sin(body.angle);

            // Calculate distance from focus (Sun)
            const r = Math.sqrt(Math.pow(x + body.focusOffset, 2) + Math.pow(z, 2));

            // Variable speed: faster when closer (simplified Kepler's 2nd law)
            const speedMultiplier = Math.pow(body.semiMajorAxis / r, 1.5);
            body.angle += body.speed * speedFactor * (speedMultiplier - 1) * 0.3;

            // Update position
            if (body.container) {
              body.container.position.set(x, 0, z);

              // Update planet trail
              if (body.trailIndex !== undefined) {
                const worldPos = new THREE.Vector3();
                body.container.getWorldPosition(worldPos);

                const trailData = planetTrails[body.trailIndex];
                trailData.positions.push(worldPos.clone());

                if (trailData.positions.length > trailData.maxLength) {
                  trailData.positions.shift();
                }

                const trailPositions = trailData.trail.geometry.attributes.position.array;
                for (let i = 0; i < trailData.positions.length; i++) {
                  const pos = trailData.positions[i];
                  trailPositions[i * 3] = pos.x;
                  trailPositions[i * 3 + 1] = pos.y;
                  trailPositions[i * 3 + 2] = pos.z;
                }
                trailData.trail.geometry.attributes.position.needsUpdate = true;
              }
            }
          }

          // Self-rotation for all bodies
          body.obj.rotation.y += body.selfRotationSpeed * speedFactor;

          // Animate ring shimmer
          if (body.rings && body.rings.length > 0) {
            body.rings.forEach((ringData, ringIndex) => {
              const shimmer = Math.sin(time * 1.5 + ringIndex) * 0.15 + 0.85;
              ringData.material.opacity = ringData.baseOpacity * shimmer;
              ringData.material.emissiveIntensity = 0.1 + Math.sin(time * 2 + ringIndex) * 0.05;
              ringData.mesh.rotation.z += 0.0001 * speedFactor;
            });
          }
        });

        // Animate Starlink satellites
        starlinkSatellites.forEach(sat => {
          // Orbit around Earth
          sat.angle += sat.speed * speedFactor * 0.5;
          const x = sat.orbitRadius * Math.cos(sat.angle);
          const z = sat.orbitRadius * Math.sin(sat.angle);
          sat.mesh.position.set(x, 0, z);

          // Slight rotation for realism
          sat.mesh.rotation.y += 0.01 * speedFactor;
        });

        // Animate user-placed asteroids with physics
        const asteroidsToRemove = [];
        userAsteroids.forEach((asteroid, index) => {
          // Apply gravity from Sun
          const sunPos = new THREE.Vector3(0, 0, 0);
          const toSun = new THREE.Vector3().subVectors(sunPos, asteroid.mesh.position);
          const distanceToSun = toSun.length();

          if (distanceToSun > 0.1) {
            const sunMass = 1000; // Relative mass of sun
            const gravityForce = (G * sunMass) / (distanceToSun * distanceToSun);
            const gravityAccel = toSun.normalize().multiplyScalar(gravityForce);
            asteroid.velocity.add(gravityAccel.multiplyScalar(speedFactor));
          }

          // Apply gravity from planets
          bodies.forEach(body => {
            if (body.name === "Sun" || body.isMoon) return;

            const planetPos = new THREE.Vector3();
            if (body.container) {
              body.container.getWorldPosition(planetPos);
            } else {
              body.obj.getWorldPosition(planetPos);
            }

            const toPlanet = new THREE.Vector3().subVectors(planetPos, asteroid.mesh.position);
            const distanceToPlanet = toPlanet.length();

            if (distanceToPlanet > 0.1) {
              // Planet mass based on radius
              const planetRadius = body.obj.geometry.parameters.radius || 1;
              const planetMass = planetRadius * planetRadius * planetRadius * 50;
              const gravityForce = (G * planetMass) / (distanceToPlanet * distanceToPlanet);
              const gravityAccel = toPlanet.normalize().multiplyScalar(gravityForce);
              asteroid.velocity.add(gravityAccel.multiplyScalar(speedFactor));
            }

            // Check for collision with planet
            const planetRadius = body.obj.geometry.parameters.radius || 1;
            if (distanceToPlanet < planetRadius + asteroid.radius) {
              asteroidsToRemove.push(index);
              return;
            }
          });

          // Check for collision with Sun
          if (distanceToSun < 3 + asteroid.radius) {
            asteroidsToRemove.push(index);
            return;
          }

          // Check for escape
          if (distanceToSun > ESCAPE_DISTANCE) {
            asteroidsToRemove.push(index);
            return;
          }

          // Update position
          asteroid.mesh.position.add(asteroid.velocity.clone().multiplyScalar(speedFactor));

          // Update trail
          asteroid.trailPositions.push(asteroid.mesh.position.clone());
          if (asteroid.trailPositions.length > asteroid.maxTrailLength) {
            asteroid.trailPositions.shift();
          }

          const trailPosArray = asteroid.trail.geometry.attributes.position.array;
          for (let i = 0; i < asteroid.trailPositions.length; i++) {
            const pos = asteroid.trailPositions[i];
            trailPosArray[i * 3] = pos.x;
            trailPosArray[i * 3 + 1] = pos.y;
            trailPosArray[i * 3 + 2] = pos.z;
          }
          // Only draw the actual number of trail positions to avoid straight line artifacts
          asteroid.trail.geometry.setDrawRange(0, asteroid.trailPositions.length);
          asteroid.trail.geometry.attributes.position.needsUpdate = true;

          // Rotate asteroid
          asteroid.mesh.rotation.x += asteroid.rotationSpeed.x * speedFactor;
          asteroid.mesh.rotation.y += asteroid.rotationSpeed.y * speedFactor;
          asteroid.mesh.rotation.z += asteroid.rotationSpeed.z * speedFactor;
        });

        // Remove collided/escaped asteroids
        asteroidsToRemove.reverse().forEach(index => {
          scene.remove(userAsteroids[index].mesh);
          scene.remove(userAsteroids[index].trail);
          userAsteroids[index].mesh.geometry.dispose();
          userAsteroids[index].mesh.material.dispose();
          userAsteroids[index].trail.geometry.dispose();
          userAsteroids[index].trail.material.dispose();
          userAsteroids.splice(index, 1);
        });
      }

      // =============================================================================
      // SPATIAL AUDIO PROCESSING
      // =============================================================================
      
      if (audioSystem.isPlaying && audioSystem.spatialEnabled) {
        // Process planets for spatial audio
        bodies.forEach(body => {
          if (!body.name || body.name === "Sun") return;
          
          const position = new THREE.Vector3();
          if (body.container) {
            body.container.getWorldPosition(position);
          } else {
            body.obj.getWorldPosition(position);
          }
          
          // Calculate distance from camera
          const distance = camera.position.distanceTo(position);
          
          // Calculate stereo pan based on screen position
          const screenPos = position.clone().project(camera);
          const pan = screenPos.x; // -1 (left) to 1 (right)
          
          // Create spatial sound for this object
          audioSystem.createSpatialSound(`planet_${body.name}`, distance, pan);
        });
        
        // Process user asteroids for spatial audio
        userAsteroids.forEach((asteroid, index) => {
          const distance = camera.position.distanceTo(asteroid.mesh.position);
          
          // Calculate stereo pan
          const screenPos = asteroid.mesh.position.clone().project(camera);
          const pan = screenPos.x;
          
          // Create spatial sound for this asteroid
          audioSystem.createSpatialSound(`asteroid_${index}`, distance, pan);
        });
        
        // Process comets for spatial audio
        comets.forEach((comet, index) => {
          const cometPos = comet.group.position;
          const distance = camera.position.distanceTo(cometPos);
          
          // Calculate stereo pan
          const screenPos = cometPos.clone().project(camera);
          const pan = screenPos.x;
          
          // Create spatial sound for this comet
          audioSystem.createSpatialSound(`comet_${index}`, distance, pan);
        });
        
        // Periodically clean up old spatial sources
        if (Math.floor(time * 10) % 50 === 0) {
          audioSystem.cleanupSpatialSources();
        }
      }

      controls.update();
      updateLabels();

      // Use post-processing if available, otherwise use standard rendering
      if (usePostProcessing && composer) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (usePostProcessing && composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    animate();
  </script>
  <script src="index.js"></script>
  <div id="hoverLabel" aria-hidden="true"></div>
</body>

</html>
