<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cartoon Solar System</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Indie+Flower&display=swap');

    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Indie Flower', cursive;
      background-color: #f5f5f5;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: #555;
      pointer-events: none;
      font-size: 18px;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      font-family: 'Indie Flower', cursive;
    }

    .planet-label {
      position: absolute;
      color: #333;
      background: rgba(255, 255, 255, 0.7);
      padding: 3px 8px;
      border-radius: 12px;
      pointer-events: none;
      font-family: 'Indie Flower', cursive;
      font-size: 14px;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
    }

    .hand-drawn {
      border: 2px dashed #999;
      box-shadow: 0 0 0 4px #fff, 0 0 10px rgba(0, 0, 0, 0.2);
      background-color: rgba(255, 255, 255, 0.5);
    }

    button {
      font-family: 'Indie Flower', cursive;
      background-color: rgba(255, 255, 255, 0.7);
      border: 1px solid #aaa;
      border-radius: 8px;
      padding: 5px 10px;
      margin: 5px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    button:hover {
      transform: translateY(-2px);
      background-color: rgba(255, 255, 255, 0.9);
    }

    button:active {
      transform: translateY(0);
    }
  </style>
</head>

<body>
  <div id="info">Solar System Sketch</div>
  <div id="controls">
    <button id="toggleAnimation">Pause</button>
    <button id="resetView">Reset View</button>
    <div class="mt-2">
      <span class="text-sm">Speed: </span>
      <input type="range" id="speedControl" min="0" max="5" step="0.1" value="1">
    </div>
  </div>

  <script>
    // Initialize Three.js scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf5f5f5);

    // Camera setup
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 20, 40);

    // Renderer
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 200;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);

    // Hand-drawn style materials
    const sunMaterial = createHandDrawnMaterial(0xffeb3b);
    const planetMaterial = (color) => createHandDrawnMaterial(color);
    const orbitMaterial = new THREE.LineBasicMaterial({
      color: 0xcccccc,
      transparent: true,
      opacity: 0.5
    });

    function createHandDrawnMaterial(color) {
      return new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.8,
        metalness: 0.1,
        flatShading: true
      });
    }

    // Celestial bodies
    const bodies = [];

    // Sun
    const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    sun.castShadow = true;
    sun.receiveShadow = true;
    scene.add(sun);
    bodies.push({obj: sun, orbitRadius: 0, name: "Sun", speed: 0});

    // Planets data (name, radius, distance from sun, orbit speed, color, tilt)
    const planetsData = [
      {name: "Mercury", radius: 0.4, distance: 7, speed: 0.04, color: 0xb97a56, tilt: 0.03},
      {name: "Venus", radius: 0.6, distance: 10, speed: 0.015, color: 0xe6c460, tilt: 177.4},
      {name: "Earth", radius: 0.7, distance: 15, speed: 0.01, color: 0x4a80f0, tilt: 23.5},
      {name: "Mars", radius: 0.5, distance: 20, speed: 0.008, color: 0xe2714b, tilt: 25.2},
      {name: "Jupiter", radius: 1.3, distance: 30, speed: 0.002, color: 0xf0b78e, tilt: 3.1},
      {name: "Saturn", radius: 1.0, distance: 38, speed: 0.0009, color: 0xf0e078, tilt: 26.7},
      {name: "Uranus", radius: 0.8, distance: 45, speed: 0.0004, color: 0x7ec7ed, tilt: 97.8},
      {name: "Neptune", radius: 0.8, distance: 52, speed: 0.0001, color: 0x4b70dd, tilt: 28.3}
    ];

    // Ring systems data
    const ringSystemsData = {
      "Jupiter": {
        rings: [
          {innerRadius: 1.4, outerRadius: 1.5, opacity: 0.3, color: 0xcccccc}
        ]
      },
      "Saturn": {
        rings: [
          {innerRadius: 1.2, outerRadius: 1.5, opacity: 0.8, color: 0xf0e078},
          {innerRadius: 1.6, outerRadius: 2.0, opacity: 0.6, color: 0xe6d068},
          {innerRadius: 2.1, outerRadius: 2.3, opacity: 0.4, color: 0xf0e078}
        ]
      },
      "Uranus": {
        rings: [
          {innerRadius: 1.1, outerRadius: 1.2, opacity: 0.4, color: 0x7ec7ed},
          {innerRadius: 1.3, outerRadius: 1.4, opacity: 0.3, color: 0x6eaada}
        ]
      },
      "Neptune": {
        rings: [
          {innerRadius: 1.1, outerRadius: 1.3, opacity: 0.3, color: 0x4b70dd},
          {innerRadius: 1.4, outerRadius: 1.5, opacity: 0.2, color: 0x3b60cd}
        ]
      }
    };

    // Earth's moon data
    const moonData = {
      name: "Moon",
      radius: 0.2,
      distance: 2,
      speed: 0.1,
      color: 0xbbbbbb
    };

    // Create planets
    planetsData.forEach(data => {
      const geometry = new THREE.SphereGeometry(data.radius, 32, 32);
      const material = planetMaterial(data.color);
      const planet = new THREE.Mesh(geometry, material);
      planet.castShadow = planet.receiveShadow = true;

      // Create orbit path
      const orbitGeometry = new THREE.BufferGeometry();
      const points = [];

      for (let i = 0; i <= 64; i++) {
        const angle = (i / 64) * Math.PI * 2;
        points.push(new THREE.Vector3(
          Math.cos(angle) * data.distance, 0, Math.sin(angle) * data.distance));
      }

      orbitGeometry.setFromPoints(points);
      const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
      
      // Pivot group for orbital motion
      const pivot = new THREE.Object3D();
      scene.add(pivot);
      pivot.add(orbitLine);
      
      // Planet container for axial tilt
      const planetContainer = new THREE.Object3D();
      planetContainer.rotation.z = THREE.MathUtils.degToRad(data.tilt);
      pivot.add(planetContainer);
      planetContainer.add(planet);
      
      // Position planet at its orbital radius
      planetContainer.position.set(data.distance, 0, 0);

      // Add ring systems if applicable
      if (ringSystemsData[data.name]) {
        const ringSystem = ringSystemsData[data.name];
        ringSystem.rings.forEach(ringData => {
          const ringGeometry = new THREE.RingGeometry(
            ringData.innerRadius, 
            ringData.outerRadius, 
            64
          );
          const ringMaterial = new THREE.MeshStandardMaterial({
            color: ringData.color,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: ringData.opacity
          });
          const ring = new THREE.Mesh(ringGeometry, ringMaterial);
          ring.rotation.x = Math.PI / 2;
          planet.add(ring);
        });
      }

      bodies.push({
        pivot: pivot,
        obj: planet,
        container: planetContainer,
        speed: data.speed,
        name: data.name
      });

      // For Earth, add the moon
      if (data.name === "Earth") {
        const moonGeometry = new THREE.SphereGeometry(moonData.radius, 32, 32);
        const moonMaterial = planetMaterial(moonData.color);
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);

        const moonPivot = new THREE.Object3D();
        planet.add(moonPivot);
        moonPivot.add(moon);
        moon.position.set(moonData.distance, 0, 0);

        bodies.push({
          pivot: moonPivot,
          obj: moon,
          speed: moonData.speed,
          name: moonData.name
        });
      }
    });

    // Animation state
    let animationPaused = false;
    let speedFactor = 1;

    // Controls
    document.getElementById('toggleAnimation').addEventListener('click', () => {
      animationPaused = !animationPaused;
      document.getElementById('toggleAnimation').textContent = animationPaused ? "Play" : "Pause";
    });

    document.getElementById('resetView').addEventListener('click', () => {
      camera.position.set(0, 20, 40);
      controls.reset();
    });

    document.getElementById('speedControl').addEventListener('input', (e) => {
      speedFactor = parseFloat(e.target.value);
    });

    // Labels
    function updateLabels() {
      // Remove existing labels
      document.querySelectorAll('.planet-label').forEach(el => el.remove());

      // Add labels for each planet
      bodies.forEach(body => {
        if (!body.name || body.name === "Moon") return; // Skip moon label to avoid clutter

        const position = new THREE.Vector3();
        if (body.container) {
          body.container.getWorldPosition(position);
        } else {
          body.obj.getWorldPosition(position);
        }

        position.project(camera);

        const x = (position.x * 0.5 + 0.5) * window.innerWidth;
        const y = (position.y * -0.5 + 0.5) * window.innerHeight;

        const label = document.createElement('div');
        label.className = 'planet-label';
        label.textContent = body.name;
        label.style.left = `${x}px`;
        label.style.top = `${y}px`;

        document.body.appendChild(label);
      });
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      if (!animationPaused) {
        bodies.forEach((body) => {
          if (body.pivot) {
            body.pivot.rotation.y += body.speed * speedFactor;  // revolution
          }
          body.obj.rotation.y += 0.005 * speedFactor;          // self-spin
        });
        sun.rotation.y += 0.002 * speedFactor;
      }

      controls.update();
      updateLabels();
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>

</html>
