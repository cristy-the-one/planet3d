<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cartoon Solar System</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Indie+Flower&display=swap');

    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Indie Flower', cursive;
      background-color: #f5f5f5;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: #555;
      pointer-events: none;
      font-size: 18px;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      font-family: 'Indie Flower', cursive;
    }

    .planet-label {
      position: absolute;
      color: #333;
      background: rgba(255, 255, 255, 0.7);
      padding: 3px 8px;
      border-radius: 12px;
      pointer-events: none;
      font-family: 'Indie Flower', cursive;
      font-size: 14px;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
    }

    .hand-drawn {
      border: 2px dashed #999;
      box-shadow: 0 0 0 4px #fff, 0 0 10px rgba(0, 0, 0, 0.2);
      background-color: rgba(255, 255, 255, 0.5);
    }

    button {
      font-family: 'Indie Flower', cursive;
      background-color: rgba(255, 255, 255, 0.7);
      border: 1px solid #aaa;
      border-radius: 8px;
      padding: 5px 10px;
      margin: 5px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    button:hover {
      transform: translateY(-2px);
      background-color: rgba(255, 255, 255, 0.9);
    }

    button:active {
      transform: translateY(0);
    }
  </style>
</head>

<body>
  <div id="info">Solar System Sketch</div>
  <div id="controls">
    <button id="toggleAnimation">Pause</button>
    <button id="resetView">Reset View</button>
    <div class="mt-2">
      <span class="text-sm">Speed: </span>
      <input type="range" id="speedControl" min="0" max="5" step="0.1" value="1">
    </div>
  </div>

  <script>
    // Initialize Three.js scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf5f5f5);

    // Camera setup
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 20, 40);

    // Renderer
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 200;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);

    // Hand-drawn style materials
    const sunMaterial = createHandDrawnMaterial(0xffeb3b);
    const planetMaterial = (color) => createHandDrawnMaterial(color);
    const orbitMaterial = new THREE.LineBasicMaterial({
      color: 0xcccccc,
      transparent: true,
      opacity: 0.5
    });

    function createHandDrawnMaterial(color) {
      return new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.8,
        metalness: 0.1,
        flatShading: true,
        shadowSide: THREE.DoubleSide
      });
    }

    // Celestial bodies
    const bodies = [];

    // Sun
    const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    sun.castShadow = true;
    sun.receiveShadow = true;
    scene.add(sun);
    //bodies.push({obj: sun, orbitRadius: 0});

    // Planets data (name, radius, distance from sun, orbit speed, color)
    const planetsData = [
      {name: "Mercury", radius: 0.4, distance: 7, speed: 0.04, color: 0xb97a56},
      {name: "Venus", radius: 0.6, distance: 10, speed: 0.015, color: 0xe6c460},
      {name: "Earth", radius: 0.7, distance: 15, speed: 0.01, color: 0x4a80f0},
      {name: "Mars", radius: 0.5, distance: 20, speed: 0.008, color: 0xe2714b},
      {name: "Jupiter", radius: 1.3, distance: 30, speed: 0.002, color: 0xf0b78e},
      {name: "Saturn", radius: 1.0, distance: 38, speed: 0.0009, color: 0xf0e078},
      {name: "Uranus", radius: 0.8, distance: 45, speed: 0.0004, color: 0x7ec7ed},
      {name: "Neptune", radius: 0.8, distance: 52, speed: 0.0001, color: 0x4b70dd}
    ];

    // Earth's moon data
    const moonData = {
      name: "Moon",
      radius: 0.2,
      distance: 2,
      speed: 0.1,
      color: 0xbbbbbb
    };

    // Create planets
    planetsData.forEach(data => {
      const geometry = new THREE.SphereGeometry(data.radius, 32, 32);
      const material = planetMaterial(data.color);
      const planet = new THREE.Mesh(geometry, material);
      planet.castShadow = planet.receiveShadow = true;

      // Create orbit path
      const orbitGeometry = new THREE.BufferGeometry();
      const points = [];

      for (let i = 0; i <= 64; i++) {
        const angle = (i / 64) * Math.PI * 2;
        points.push(new THREE.Vector3(
          Math.cos(angle) * data.distance, 0, Math.sin(angle) * data.distance));
      }

      orbitGeometry.setFromPoints(points);
      const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
      //pivot group  everything inside keeps the same tilt & motion
      const pivot = new THREE.Object3D();
      scene.add(pivot);

      // optional: give the whole orbit a *small* individual axial tilt
      // pivot.rotation.x = THREE.MathUtils.degToRad(data.tilt || 0);

      pivot.add(orbitLine);
      pivot.add(planet);


      // push the planet out to its orbital radius once;
      // the pivots rotation will do the actual revolution
      planet.position.set(data.distance, 0, 0);

      bodies.push({
        pivot,          // << we animate this
        obj: planet,    // the mesh (for labels & self-rotation)
        speed: data.speed,
        name: data.name
      });
      // For Earth, add the moon
      if (data.name === "Earth") {
        const moonGeometry = new THREE.SphereGeometry(moonData.radius, 32, 32);
        const moonMaterial = planetMaterial(moonData.color);
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);

        const moonPivot = new THREE.Object3D();
        planet.add(moonPivot);
        moonPivot.add(moon);
        moon.position.set(moonData.distance, 0, 0);

        bodies.push({
          pivot: moonPivot,
          obj: moon,
          speed: moonData.speed,
          name: moonData.name
        });
      }
    });

    // Add rings to Saturn
    const saturn = bodies.find(b => b.name === "Saturn").obj;
    const ringGeometry = new THREE.RingGeometry(1.2, 2.0, 32);
    const ringMaterial = planetMaterial(0xf0e078);
    ringMaterial.transparent = true;
    ringMaterial.opacity = 0.6;
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.rotation.x = Math.PI / 2;
    ring.rotation.z = Math.PI / 5;
    saturn.add(ring);

    // Animation state
    let animationPaused = false;
    let speedFactor = 1;

    // Controls
    document.getElementById('toggleAnimation').addEventListener('click', () => {
      animationPaused = !animationPaused;
      document.getElementById('toggleAnimation').textContent = animationPaused ? "Play" : "Pause";
    });

    document.getElementById('resetView').addEventListener('click', () => {
      camera.position.set(0, 20, 40);
      controls.reset();
    });

    document.getElementById('speedControl').addEventListener('input', (e) => {
      speedFactor = parseFloat(e.target.value);
    });

    // Labels
    function updateLabels() {
      // Remove existing labels
      document.querySelectorAll('.planet-label').forEach(el => el.remove());

      // Add labels for each planet
      bodies.forEach(body => {
        if (!body.name) return;

        const position = new THREE.Vector3();
        body.obj.getWorldPosition(position);

        position.project(camera);

        const x = (position.x * 0.5 + 0.5) * window.innerWidth;
        const y = (position.y * -0.5 + 0.5) * window.innerHeight;

        const label = document.createElement('div');
        label.className = 'planet-label';
        label.textContent = body.name;
        label.style.left = `${x}px`;
        label.style.top = `${y}px`;

        document.body.appendChild(label);
      });
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      if (!animationPaused) {
        bodies.forEach((body) => {
          body.pivot.rotation.y += body.speed * speedFactor;  // revolution
          body.obj.rotation.y += 0.005;                      // self-spin
        });
        sun.rotation.y += 0.002 * speedFactor;
      }

      controls.update();
      updateLabels();
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>

</html>
