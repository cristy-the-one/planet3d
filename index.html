<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spectacular Solar System</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Indie+Flower&display=swap');

    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Indie Flower', cursive;
      background-color: #000;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: #fff;
      pointer-events: none;
      font-size: 18px;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      font-family: 'Indie Flower', cursive;
      color: #fff;
    }

    .planet-label {
      position: absolute;
      color: #fff;
      background: rgba(0, 0, 0, 0.7);
      padding: 3px 8px;
      border-radius: 12px;
      pointer-events: none;
      font-family: 'Indie Flower', cursive;
      font-size: 14px;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.1);
    }

    .hand-drawn {
      border: 2px dashed #999;
      box-shadow: 0 0 0 4px #fff, 0 0 10px rgba(255, 255, 255, 0.2);
      background-color: rgba(255, 255, 255, 0.3);
    }

    button {
      font-family: 'Indie Flower', cursive;
      background-color: rgba(255, 255, 255, 0.2);
      border: 1px solid #888;
      color: #fff;
      border-radius: 8px;
      padding: 5px 10px;
      margin: 5px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    button:hover {
      transform: translateY(-2px);
      background-color: rgba(255, 255, 255, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    select {
      font-family: 'Indie Flower', cursive;
      background-color: rgba(255, 255, 255, 0.2);
      border: 1px solid #888;
      color: #fff;
      border-radius: 8px;
      padding: 5px 10px;
      cursor: pointer;
    }

    select option {
      background-color: #000;
      color: #fff;
    }
  </style>
</head>

<body>
  <div id="info">‚ú® Spectacular Solar System ‚ú®</div>
  <div id="controls">
    <button id="toggleAnimation">Pause</button>
    <button id="toggleFreeze">Freeze (Place Asteroids)</button>
    <button id="resetView">Reset View</button>
    <button id="toggleSatellites">Satellites: Highly Visible</button>
    <div class="mt-2">
      <span class="text-sm">Speed: </span>
      <input type="range" id="speedControl" min="0" max="2" step="0.05" value="0.5">
    </div>
    <div class="mt-2">
      <span class="text-sm">View from: </span>
      <select id="planetSelector">
        <option value="Sun">Sun</option>
      </select>
    </div>
  </div>

  <script>
    // Initialize Three.js scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000508);
    scene.fog = new THREE.FogExp2(0x000508, 0.00025);

    // Camera setup
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 20, 40);

    // Renderer with enhanced settings
    const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.8;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Post-processing setup (optional, with fallback)
    let composer = null;
    let usePostProcessing = false;

    try {
      if (typeof THREE.EffectComposer !== 'undefined' &&
          typeof THREE.RenderPass !== 'undefined' &&
          typeof THREE.UnrealBloomPass !== 'undefined') {
        composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,  // strength
          0.4,  // radius
          0.85  // threshold
        );
        composer.addPass(bloomPass);
        usePostProcessing = true;
        console.log('‚ú® Post-processing enabled with bloom effect');
      } else {
        console.warn('‚ö†Ô∏è Post-processing libraries not loaded, using standard rendering');
      }
    } catch (error) {
      console.error('‚ùå Error setting up post-processing:', error);
      console.log('üìå Falling back to standard rendering');
      usePostProcessing = false;
    }

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 300;

    // Lighting - dramatic setup
    const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
    scene.add(ambientLight);

    // Sun point light (will be positioned at sun)
    const sunLight = new THREE.PointLight(0xfff4e6, 3, 300);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;
    scene.add(sunLight);

    // Enhanced star field with colors and sizes
    const starCount = 5000;
    const starGeometry = new THREE.BufferGeometry();
    const starVertices = [];
    const starColors = [];
    const starSizes = [];
    const starTwinklePhases = [];

    for (let i = 0; i < starCount; i++) {
      const baseRadius = 800;
      const offset = Math.random() * 400;
      const r = baseRadius + offset;
      const theta = Math.acos(2 * Math.random() - 1);
      const phi = 2 * Math.PI * Math.random();
      const x = r * Math.sin(theta) * Math.cos(phi);
      const y = r * Math.sin(theta) * Math.sin(phi);
      const z = r * Math.cos(theta);
      starVertices.push(x, y, z);

      // Star colors - mix of white, blue-white, yellow-white, and red
      const colorType = Math.random();
      let color;
      if (colorType < 0.6) {
        color = new THREE.Color(0xffffff); // White
      } else if (colorType < 0.8) {
        color = new THREE.Color(0xaaccff); // Blue-white
      } else if (colorType < 0.95) {
        color = new THREE.Color(0xffffcc); // Yellow-white
      } else {
        color = new THREE.Color(0xffccaa); // Red
      }
      starColors.push(color.r, color.g, color.b);

      // Varying sizes
      starSizes.push(Math.random() * 3 + 0.5);

      // Random twinkle phase
      starTwinklePhases.push(Math.random() * Math.PI * 2);
    }

    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
    starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
    starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
    starGeometry.setAttribute('twinklePhase', new THREE.Float32BufferAttribute(starTwinklePhases, 1));

    const starMaterial = new THREE.PointsMaterial({
      size: 2,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      sizeAttenuation: false,
      blending: THREE.AdditiveBlending
    });

    const starField = new THREE.Points(starGeometry, starMaterial);
    scene.add(starField);

    // Create colorful nebula clouds
    const nebulaGroups = [];
    const nebulaColors = [
      { color: 0x8844ff, pos: new THREE.Vector3(300, 200, -500) },
      { color: 0xff4488, pos: new THREE.Vector3(-400, -150, -600) },
      { color: 0x44ff88, pos: new THREE.Vector3(250, -300, -700) },
      { color: 0xff8844, pos: new THREE.Vector3(-300, 250, -550) }
    ];

    nebulaColors.forEach(nebulaData => {
      const nebulaGroup = new THREE.Group();
      for (let i = 0; i < 3; i++) {
        const size = 150 + Math.random() * 100;
        const nebulaGeometry = new THREE.SphereGeometry(size, 32, 32);
        const nebulaMaterial = new THREE.MeshBasicMaterial({
          color: nebulaData.color,
          transparent: true,
          opacity: 0.03 + Math.random() * 0.02,
          blending: THREE.AdditiveBlending
        });
        const nebulaMesh = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
        nebulaMesh.position.set(
          (Math.random() - 0.5) * 100,
          (Math.random() - 0.5) * 100,
          (Math.random() - 0.5) * 100
        );
        nebulaGroup.add(nebulaMesh);
      }
      nebulaGroup.position.copy(nebulaData.pos);
      scene.add(nebulaGroup);
      nebulaGroups.push(nebulaGroup);
    });

    // Space dust particles
    const dustCount = 1000;
    const dustGeometry = new THREE.BufferGeometry();
    const dustVertices = [];
    const dustVelocities = [];

    for (let i = 0; i < dustCount; i++) {
      dustVertices.push(
        (Math.random() - 0.5) * 200,
        (Math.random() - 0.5) * 200,
        (Math.random() - 0.5) * 200
      );
      dustVelocities.push(
        (Math.random() - 0.5) * 0.02,
        (Math.random() - 0.5) * 0.02,
        (Math.random() - 0.5) * 0.02
      );
    }

    dustGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dustVertices, 3));
    const dustMaterial = new THREE.PointsMaterial({
      color: 0xaaaaaa,
      size: 0.5,
      transparent: true,
      opacity: 0.4,
      sizeAttenuation: true,
      blending: THREE.AdditiveBlending
    });

    const spaceDust = new THREE.Points(dustGeometry, dustMaterial);
    scene.add(spaceDust);

    // Hand-drawn style materials
    const sunMaterial = createHandDrawnMaterial(0xffeb3b);
    const planetMaterial = (color) => createHandDrawnMaterial(color);

    // Texture for Earth skin
    const earthTexture = new THREE.TextureLoader().load('IMG_3077.jpeg');
    const orbitMaterial = new THREE.LineBasicMaterial({
      color: 0xa5a5a5,
      transparent: true,
      opacity: 0.7
    });

    function createHandDrawnMaterial(color) {
      return new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.8,
        metalness: 0.1,
        flatShading: true
      });
    }

    // Celestial bodies
    const bodies = [];

    // Spectacular Sun with multiple layers
    const sunGroup = new THREE.Group();

    // Core sun
    const sunGeometry = new THREE.SphereGeometry(3, 64, 64);
    const sunCoreMaterial = new THREE.MeshStandardMaterial({
      color: 0xffff00,
      emissive: 0xffff00,
      emissiveIntensity: 2,
      roughness: 1.0,
      metalness: 0.0
    });
    const sun = new THREE.Mesh(sunGeometry, sunCoreMaterial);
    sunGroup.add(sun);

    // Sun glow layer 1
    const sunGlow1Geometry = new THREE.SphereGeometry(3.3, 64, 64);
    const sunGlow1Material = new THREE.MeshBasicMaterial({
      color: 0xffaa00,
      transparent: true,
      opacity: 0.4,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide
    });
    const sunGlow1 = new THREE.Mesh(sunGlow1Geometry, sunGlow1Material);
    sunGroup.add(sunGlow1);

    // Sun glow layer 2 (corona)
    const sunGlow2Geometry = new THREE.SphereGeometry(4, 64, 64);
    const sunGlow2Material = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.2,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide
    });
    const sunGlow2 = new THREE.Mesh(sunGlow2Geometry, sunGlow2Material);
    sunGroup.add(sunGlow2);

    // Outer corona
    const sunGlow3Geometry = new THREE.SphereGeometry(5.5, 64, 64);
    const sunGlow3Material = new THREE.MeshBasicMaterial({
      color: 0xffdd88,
      transparent: true,
      opacity: 0.1,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide
    });
    const sunGlow3 = new THREE.Mesh(sunGlow3Geometry, sunGlow3Material);
    sunGroup.add(sunGlow3);

    scene.add(sunGroup);
    sunLight.position.set(0, 0, 0);

    bodies.push({
      obj: sun,
      group: sunGroup,
      glow1: sunGlow1,
      glow2: sunGlow2,
      glow3: sunGlow3,
      orbitRadius: 0,
      name: "Sun",
      speed: 0,
      selfRotationSpeed: 0.001
    });

    // Planets data with orbital elements
    const planetsData = [
      {name: "Mercury", radius: 0.4, semiMajorAxis: 7, speed: 0.04, color: 0xb97a56, tilt: 0.03, 
       eccentricity: 0.206, inclination: 7.0, moons: []},
      {name: "Venus", radius: 0.6, semiMajorAxis: 10, speed: 0.015, color: 0xe6c460, tilt: 177.4, 
       eccentricity: 0.007, inclination: 3.4, moons: []},
      {name: "Earth", radius: 0.7, semiMajorAxis: 15, speed: 0.01, color: 0x4a80f0, tilt: 23.5, 
       eccentricity: 0.017, inclination: 0, moons: [
        {name: "Moon", radius: 0.2, distance: 2, speed: 0.1, color: 0xcfcfcf}
      ]},
      {name: "Mars", radius: 0.5, semiMajorAxis: 20, speed: 0.008, color: 0xe2714b, tilt: 25.2, 
       eccentricity: 0.093, inclination: 1.85, moons: [
        {name: "Phobos", radius: 0.08, distance: 1.2, speed: 0.15, color: 0x9e7b60},
        {name: "Deimos", radius: 0.06, distance: 1.8, speed: 0.08, color: 0xa88c75}
      ]},
      {name: "Jupiter", radius: 1.3, semiMajorAxis: 30, speed: 0.002, color: 0xf0b78e, tilt: 3.1, 
       eccentricity: 0.049, inclination: 1.3, moons: [
        {name: "Io", radius: 0.25, distance: 2.2, speed: 0.12, color: 0xffcc66},
        {name: "Europa", radius: 0.22, distance: 2.8, speed: 0.09, color: 0xddeeff},
        {name: "Ganymede", radius: 0.3, distance: 3.5, speed: 0.06, color: 0xb0a090},
        {name: "Callisto", radius: 0.28, distance: 4.5, speed: 0.04, color: 0x8f7e6b}
      ]},
      {name: "Saturn", radius: 1.0, semiMajorAxis: 38, speed: 0.0009, color: 0xf0e078, tilt: 26.7, 
       eccentricity: 0.057, inclination: 2.5, moons: [
        {name: "Enceladus", radius: 0.1, distance: 1.8, speed: 0.12, color: 0xffffff},
        {name: "Titan", radius: 0.35, distance: 3.5, speed: 0.06, color: 0xe0c080}
      ]},
      {name: "Uranus", radius: 0.8, semiMajorAxis: 45, speed: 0.0004, color: 0x7ec7ed, tilt: 97.8, 
       eccentricity: 0.046, inclination: 0.77, moons: [
        {name: "Titania", radius: 0.15, distance: 2.2, speed: 0.08, color: 0xb0c4de},
        {name: "Oberon", radius: 0.14, distance: 2.8, speed: 0.06, color: 0xaaaaff}
      ]},
      {name: "Neptune", radius: 0.8, semiMajorAxis: 52, speed: 0.0001, color: 0x4b70dd, tilt: 28.3, 
       eccentricity: 0.011, inclination: 1.77, moons: [
        {name: "Triton", radius: 0.18, distance: 2.5, speed: 0.07, color: 0xc0d6e4}
      ]}
    ];

    // Ring systems data
    const ringSystemsData = {
      "Jupiter": {
        rings: [
          {innerRadius: 1.4, outerRadius: 1.5, opacity: 0.3, color: 0xcccccc}
        ]
      },
      "Saturn": {
        rings: [
          {innerRadius: 1.2, outerRadius: 1.5, opacity: 0.8, color: 0xf0e078},
          {innerRadius: 1.6, outerRadius: 2.0, opacity: 0.6, color: 0xe6d068},
          {innerRadius: 2.1, outerRadius: 2.3, opacity: 0.4, color: 0xf0e078}
        ]
      },
      "Uranus": {
        rings: [
          {innerRadius: 1.1, outerRadius: 1.2, opacity: 0.4, color: 0x7ec7ed},
          {innerRadius: 1.3, outerRadius: 1.4, opacity: 0.3, color: 0x6eaada}
        ]
      },
      "Neptune": {
        rings: [
          {innerRadius: 1.1, outerRadius: 1.3, opacity: 0.3, color: 0x4b70dd},
          {innerRadius: 1.4, outerRadius: 1.5, opacity: 0.2, color: 0x3b60cd}
        ]
      }
    };

    // Particle trail systems for planets
    const planetTrails = [];

    // Create planets
    planetsData.forEach(data => {
      const geometry = new THREE.SphereGeometry(data.radius, 32, 32);
      let material;
      if (data.name === "Earth") {
        material = new THREE.MeshStandardMaterial({
          map: earthTexture,
          metalness: 0.2,
          roughness: 0.8
        });
      } else {
        material = planetMaterial(data.color);
      }
      const planet = new THREE.Mesh(geometry, material);
      planet.castShadow = planet.receiveShadow = true;

      // Add atmospheric glow for planets with atmospheres
      const hasAtmosphere = ["Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"].includes(data.name);
      if (hasAtmosphere) {
        const glowGeometry = new THREE.SphereGeometry(data.radius * 1.15, 32, 32);
        let atmosphereColor;
        switch(data.name) {
          case "Earth": atmosphereColor = 0x6699ff; break;
          case "Venus": atmosphereColor = 0xe6c460; break;
          case "Mars": atmosphereColor = 0xe2714b; break;
          case "Jupiter": atmosphereColor = 0xf0b78e; break;
          case "Saturn": atmosphereColor = 0xf0e078; break;
          case "Uranus": atmosphereColor = 0x7ec7ed; break;
          case "Neptune": atmosphereColor = 0x4b70dd; break;
          default: atmosphereColor = 0x88aaff;
        }
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: atmosphereColor,
          transparent: true,
          opacity: 0.15,
          side: THREE.BackSide,
          blending: THREE.AdditiveBlending
        });
        const atmosphereGlow = new THREE.Mesh(glowGeometry, glowMaterial);
        planet.add(atmosphereGlow);
      }

      // Create particle trail for this planet
      const trailPositions = [];
      for (let i = 0; i < 100; i++) {
        trailPositions.push(0, 0, 0);
      }
      const trailGeometry = new THREE.BufferGeometry();
      trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
      const trailMaterial = new THREE.LineBasicMaterial({
        color: data.color,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });
      const trail = new THREE.Line(trailGeometry, trailMaterial);
      scene.add(trail);
      planetTrails.push({ trail: trail, positions: [], maxLength: 100 });

      // Calculate ellipse parameters
      const a = data.semiMajorAxis;
      const e = data.eccentricity;
      const b = a * Math.sqrt(1 - e * e); // semi-minor axis
      const c = a * e; // distance from center to focus

      // Create elliptical orbit path
      const orbitGeometry = new THREE.BufferGeometry();
      const points = [];

      for (let i = 0; i <= 128; i++) {
        const angle = (i / 128) * Math.PI * 2;
        // Ellipse centered at origin
        const x = a * Math.cos(angle);
        const z = b * Math.sin(angle);
        // Shift so Sun is at one focus
        points.push(new THREE.Vector3(x - c, 0, z));
      }

      orbitGeometry.setFromPoints(points);
      const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
      
      // Orbit group for inclination
      const orbitGroup = new THREE.Object3D();
      orbitGroup.rotation.x = THREE.MathUtils.degToRad(data.inclination);
      scene.add(orbitGroup);
      
      // Pivot group for orbital motion
      const pivot = new THREE.Object3D();
      pivot.position.x = -c; // Offset pivot to focus
      orbitGroup.add(pivot);
      orbitGroup.add(orbitLine);
      
      // Planet container for axial tilt
      const planetContainer = new THREE.Object3D();
      planetContainer.rotation.z = THREE.MathUtils.degToRad(data.tilt);
      pivot.add(planetContainer);
      planetContainer.add(planet);
      
      // Position planet at random starting angle on orbit
      const startAngle = Math.random() * Math.PI * 2;
      const x = a * Math.cos(startAngle);
      const z = b * Math.sin(startAngle);
      planetContainer.position.set(x, 0, z);

      // Add ring systems if applicable
      const planetRings = [];
      if (ringSystemsData[data.name]) {
        const ringSystem = ringSystemsData[data.name];
        ringSystem.rings.forEach(ringData => {
          const ringGeometry = new THREE.RingGeometry(
            ringData.innerRadius,
            ringData.outerRadius,
            128
          );
          const ringMaterial = new THREE.MeshStandardMaterial({
            color: ringData.color,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: ringData.opacity,
            emissive: ringData.color,
            emissiveIntensity: 0.1,
            metalness: 0.3,
            roughness: 0.7
          });
          const ring = new THREE.Mesh(ringGeometry, ringMaterial);
          ring.rotation.x = Math.PI / 2;
          planet.add(ring);
          planetRings.push({
            mesh: ring,
            baseOpacity: ringData.opacity,
            material: ringMaterial
          });
        });
      }

      const bodyIndex = bodies.length;
      bodies.push({
        pivot: pivot,
        obj: planet,
        container: planetContainer,
        speed: data.speed,
        selfRotationSpeed: 0.005,
        name: data.name,
        angle: startAngle, // Use the random starting angle
        semiMajorAxis: a,
        semiMinorAxis: b,
        eccentricity: e,
        focusOffset: c,
        trailIndex: planetTrails.length - 1,
        rings: planetRings
      });

      // Add moons for this planet
      if (data.moons && data.moons.length > 0) {
        data.moons.forEach(moonData => {
          const moonGeometry = new THREE.SphereGeometry(moonData.radius, 32, 32);
          const moonMaterial = planetMaterial(moonData.color);
          const moon = new THREE.Mesh(moonGeometry, moonMaterial);
          moon.castShadow = moon.receiveShadow = true;

          // Create moon orbit around planet
          const moonPivot = new THREE.Object3D();
          planet.add(moonPivot);
          moonPivot.add(moon);
          moon.position.set(moonData.distance, 0, 0);

          // Add moon orbit line
          const moonOrbitGeometry = new THREE.BufferGeometry();
          const moonOrbitPoints = [];
          for (let i = 0; i <= 32; i++) {
            const angle = (i / 32) * Math.PI * 2;
            moonOrbitPoints.push(new THREE.Vector3(
              Math.cos(angle) * moonData.distance, 0, Math.sin(angle) * moonData.distance
            ));
          }
          moonOrbitGeometry.setFromPoints(moonOrbitPoints);
          const moonOrbitLine = new THREE.Line(moonOrbitGeometry, new THREE.LineBasicMaterial({
            color: 0x555555,
            transparent: true,
            opacity: 0.3
          }));
          planet.add(moonOrbitLine);

          bodies.push({
            pivot: moonPivot,
            obj: moon,
            speed: moonData.speed,
            selfRotationSpeed: 0.005,
            name: moonData.name,
            isMoon: true
          });
        });
      }
    });

    // Function to create a classical communication satellite
    function createSatellite() {
      const satelliteGroup = new THREE.Group();

      // Main body (small box) - reduced size 10x
      const bodyGeometry = new THREE.BoxGeometry(0.004, 0.004, 0.006);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        metalness: 0.8,
        roughness: 0.2,
        emissive: 0x4488ff,
        emissiveIntensity: 0.3
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      satelliteGroup.add(body);

      // Solar panels (two wings) - reduced size 10x
      const panelGeometry = new THREE.BoxGeometry(0.012, 0.008, 0.0002);
      const panelMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a3a5a,
        metalness: 0.5,
        roughness: 0.3,
        emissive: 0x0088ff,
        emissiveIntensity: 0.2
      });

      // Left panel
      const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
      leftPanel.position.set(-0.008, 0, 0);
      satelliteGroup.add(leftPanel);

      // Right panel
      const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
      rightPanel.position.set(0.008, 0, 0);
      satelliteGroup.add(rightPanel);

      // Small antenna - reduced size 10x
      const antennaGeometry = new THREE.CylinderGeometry(0.0002, 0.0002, 0.003, 8);
      const antennaMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.9,
        roughness: 0.1
      });
      const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
      antenna.position.set(0, 0.0035, 0);
      satelliteGroup.add(antenna);

      return satelliteGroup;
    }

    // Starlink Satellite Constellation around Earth
    const starlinkSatellites = [];
    const starlinkGroup = new THREE.Group();

    // Find Earth in the bodies array
    const earthBody = bodies.find(b => b.name === "Earth");

    if (earthBody) {
      // Create multiple orbital rings
      const numRings = 8; // Number of orbital planes
      const satellitesPerRing = 30; // Satellites per ring
      const baseOrbitRadius = 1.2; // Starting orbit radius (visible distance from Earth)
      const orbitSpacing = 0.15; // Spacing between rings

      for (let ring = 0; ring < numRings; ring++) {
        const orbitRadius = baseOrbitRadius + (ring * orbitSpacing);
        const ringInclination = (ring * 180 / numRings) % 180; // Different inclinations

        for (let sat = 0; sat < satellitesPerRing; sat++) {
          const satellite = createSatellite();

          // Random starting position on orbit
          const startAngle = (sat / satellitesPerRing) * Math.PI * 2 + Math.random() * 0.2;

          // Position satellite on orbit
          const x = orbitRadius * Math.cos(startAngle);
          const z = orbitRadius * Math.sin(startAngle);
          satellite.position.set(x, 0, z);

          // Random rotation
          satellite.rotation.set(
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
          );

          // Create orbital ring container
          const orbitContainer = new THREE.Object3D();
          orbitContainer.rotation.x = THREE.MathUtils.degToRad(ringInclination);
          orbitContainer.add(satellite);

          // Add to Earth (so satellites follow Earth)
          earthBody.obj.add(orbitContainer);

          starlinkSatellites.push({
            mesh: satellite,
            orbitContainer: orbitContainer,
            orbitRadius: orbitRadius,
            angle: startAngle,
            speed: 0.02 + Math.random() * 0.01, // Vary orbital speeds slightly
            ring: ring
          });
        }
      }
    }

    // Satellite visibility state
    let satelliteVisibility = 'highly'; // 'highly' or 'slightly'

    // Function to update satellite visibility
    function updateSatelliteVisibility() {
      starlinkSatellites.forEach(sat => {
        if (satelliteVisibility === 'highly') {
          sat.mesh.scale.set(2.8, 2.8, 2.8); // Normal size for high visibility
          sat.mesh.children.forEach(child => {
            if (child.material && child.material.emissive) {
              // Standard emissive intensity
              if (child === sat.mesh.children[0]) { // body
                child.material.emissiveIntensity = 0.5;
              } else if (child.geometry instanceof THREE.BoxGeometry) { // panels
                child.material.emissiveIntensity = 0.25;
              }
            }
          });
        } else {
          sat.mesh.scale.set(1.3, 1.3, 1.3); // Much smaller for slight visibility
          sat.mesh.children.forEach(child => {
            if (child.material && child.material.emissive) {
              // Reduced emissive intensity
              if (child === sat.mesh.children[0]) { // body
                child.material.emissiveIntensity = 0.25;
              } else if (child.geometry instanceof THREE.BoxGeometry) { // panels
                child.material.emissiveIntensity = 0.15;
              }
            }
          });
        }
      });
    }

    // Initialize satellite visibility
    updateSatelliteVisibility();

    // Asteroid Belt (between Mars and Jupiter)
    const asteroidBelt = [];
    const asteroidCount = 800;
    const asteroidGroup = new THREE.Group();

    for (let i = 0; i < asteroidCount; i++) {
      const radius = 0.05 + Math.random() * 0.15;
      const geometry = new THREE.DodecahedronGeometry(radius, 0);
      const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color().setHSL(0.05 + Math.random() * 0.05, 0.3, 0.3 + Math.random() * 0.2),
        roughness: 0.9,
        metalness: 0.1
      });
      const asteroid = new THREE.Mesh(geometry, material);
      asteroid.castShadow = true;
      asteroid.receiveShadow = true;

      // Position in belt
      const angle = Math.random() * Math.PI * 2;
      const distance = 23 + Math.random() * 5; // Between Mars (20) and Jupiter (30)
      const height = (Math.random() - 0.5) * 1.5;

      asteroid.position.set(
        Math.cos(angle) * distance,
        height,
        Math.sin(angle) * distance
      );

      asteroid.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );

      asteroidGroup.add(asteroid);
      asteroidBelt.push({
        mesh: asteroid,
        rotationSpeed: {
          x: (Math.random() - 0.5) * 0.01,
          y: (Math.random() - 0.5) * 0.01,
          z: (Math.random() - 0.5) * 0.01
        },
        orbitSpeed: 0.005 + Math.random() * 0.003,
        distance: distance,
        angle: angle
      });
    }
    scene.add(asteroidGroup);

    // Create spectacular comets
    const comets = [];
    const cometCount = 2;

    for (let i = 0; i < cometCount; i++) {
      const cometGroup = new THREE.Group();

      // Comet nucleus
      const nucleusGeometry = new THREE.SphereGeometry(0.3, 16, 16);
      const nucleusMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        emissive: 0x4488ff,
        emissiveIntensity: 0.5,
        roughness: 0.9
      });
      const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
      cometGroup.add(nucleus);

      // Coma (glowing atmosphere around nucleus)
      const comaGeometry = new THREE.SphereGeometry(0.6, 16, 16);
      const comaMaterial = new THREE.MeshBasicMaterial({
        color: 0x88ccff,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });
      const coma = new THREE.Mesh(comaGeometry, comaMaterial);
      cometGroup.add(coma);

      // Particle tail
      const tailParticleCount = 300;
      const tailGeometry = new THREE.BufferGeometry();
      const tailPositions = [];
      const tailColors = [];
      const tailSizes = [];

      for (let j = 0; j < tailParticleCount; j++) {
        tailPositions.push(0, 0, 0);
        const color = new THREE.Color(0x88ccff);
        tailColors.push(color.r, color.g, color.b);
        tailSizes.push(Math.random() * 0.3 + 0.1);
      }

      tailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(tailPositions, 3));
      tailGeometry.setAttribute('color', new THREE.Float32BufferAttribute(tailColors, 3));
      tailGeometry.setAttribute('size', new THREE.Float32BufferAttribute(tailSizes, 1));

      const tailMaterial = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        transparent: true,
        opacity: 0.35,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
      });

      const tail = new THREE.Points(tailGeometry, tailMaterial);
      cometGroup.add(tail);

      scene.add(cometGroup);

      // Comet orbit parameters (highly elliptical)
      const semiMajorAxis = 60 + i * 20;
      const eccentricity = 0.7 + Math.random() * 0.2;
      const inclination = (Math.random() - 0.5) * 30;

      comets.push({
        group: cometGroup,
        nucleus: nucleus,
        coma: coma,
        tail: tail,
        tailPositions: tailPositions,
        speed: 0.002 + Math.random() * 0.001,
        angle: Math.random() * Math.PI * 2,
        semiMajorAxis: semiMajorAxis,
        eccentricity: eccentricity,
        inclination: inclination
      });
    }

    // Animation state
    let animationPaused = false;
    let speedFactor = 0.5;
    let selectedPlanet = null;
    let cameraAnimating = false;
    let cameraAnimationProgress = 0;
    let cameraStartPos = new THREE.Vector3();
    let cameraEndPos = new THREE.Vector3();
    let cameraStartTarget = new THREE.Vector3();
    let cameraEndTarget = new THREE.Vector3();

    // Freeze mode for asteroid placement
    let freezeMode = false;
    let userAsteroids = [];
    const MAX_USER_ASTEROIDS = 100; // Support more than 50
    const ESCAPE_DISTANCE = 400; // Distance at which asteroids are removed
    const G = 0.1; // Gravitational constant for simulation

    // Populate planet selector
    const planetSelector = document.getElementById('planetSelector');
    // Filter to get only planets (not moons) and add them in order
    const planetsForSelector = bodies.filter(body => !body.isMoon);
    planetsForSelector.forEach(body => {
      if (body.name !== "Sun") {
        const option = document.createElement('option');
        option.value = body.name;
        option.textContent = body.name;
        planetSelector.appendChild(option);
      }
    });

    // Planet selector change handler
    planetSelector.addEventListener('change', (e) => {
      const planetName = e.target.value;
      const targetBody = bodies.find(b => b.name === planetName);
      
      if (!targetBody) return;
      
      // Store current camera position and target
      cameraStartPos.copy(camera.position);
      cameraStartTarget.copy(controls.target);
      
      // Calculate new camera position and target
      const targetPos = new THREE.Vector3();
      if (targetBody.container) {
        targetBody.container.getWorldPosition(targetPos);
      } else {
        targetBody.obj.getWorldPosition(targetPos);
      }
      
      if (planetName === "Sun") {
        // Reset to original view
        cameraEndPos.set(0, 20, 40);
        cameraEndTarget.set(0, 0, 0);
        selectedPlanet = null;
      } else {
        // Set camera to view from planet's perspective
        cameraEndTarget.copy(targetPos);
        
        // Calculate camera offset based on planet size
        const planetRadius = targetBody.obj.geometry.parameters.radius || 1;
        const offset = planetRadius * 5; // Distance from planet
        
        // Position camera offset from planet
        cameraEndPos.copy(targetPos);
        cameraEndPos.y += offset * 0.5;
        cameraEndPos.z += offset;
        
        selectedPlanet = targetBody;
      }
      
      // Start animation
      cameraAnimating = true;
      cameraAnimationProgress = 0;
    });

    // Controls
    document.getElementById('toggleAnimation').addEventListener('click', () => {
      animationPaused = !animationPaused;
      document.getElementById('toggleAnimation').textContent = animationPaused ? "Play" : "Pause";
    });

    document.getElementById('toggleFreeze').addEventListener('click', () => {
      freezeMode = !freezeMode;
      document.getElementById('toggleFreeze').textContent = freezeMode ? "Unfreeze" : "Freeze (Place Asteroids)";
      if (freezeMode) {
        animationPaused = true;
        document.getElementById('toggleAnimation').textContent = "Play";
        document.getElementById('toggleAnimation').disabled = true;
        renderer.domElement.style.cursor = 'crosshair';
      } else {
        // Automatically resume simulation when unfreezing
        animationPaused = false;
        document.getElementById('toggleAnimation').textContent = "Pause";
        document.getElementById('toggleAnimation').disabled = false;
        renderer.domElement.style.cursor = 'default';
      }
    });

    document.getElementById('resetView').addEventListener('click', () => {
      camera.position.set(0, 20, 40);
      controls.target.set(0, 0, 0);
      controls.reset();
      selectedPlanet = null;
      planetSelector.value = "Sun";
    });

    document.getElementById('speedControl').addEventListener('input', (e) => {
      speedFactor = parseFloat(e.target.value);
    });

    document.getElementById('toggleSatellites').addEventListener('click', () => {
      satelliteVisibility = satelliteVisibility === 'highly' ? 'slightly' : 'highly';
      document.getElementById('toggleSatellites').textContent =
        `Satellites: ${satelliteVisibility === 'highly' ? 'Highly' : 'Slightly'} Visible`;
      updateSatelliteVisibility();
    });

    // Click handler for placing asteroids
    function onCanvasClick(event) {
      if (!freezeMode || userAsteroids.length >= MAX_USER_ASTEROIDS) return;

      // Calculate mouse position in normalized device coordinates
      const mouse = new THREE.Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Raycast to find position in 3D space
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Use a plane at y=0 for placement
      const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersection = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersection);

      if (intersection) {
        createUserAsteroid(intersection);
      }
    }

    function createUserAsteroid(position) {
      // Create asteroid mesh
      const radius = 0.2 + Math.random() * 0.2;
      const geometry = new THREE.DodecahedronGeometry(radius, 0);
      // Bright cyan color to distinguish from asteroid belt (brown/gray)
      const material = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        roughness: 0.7,
        metalness: 0.3,
        emissive: 0x00ccff,
        emissiveIntensity: 0.8
      });
      const asteroid = new THREE.Mesh(geometry, material);
      asteroid.castShadow = true;
      asteroid.receiveShadow = true;
      asteroid.position.copy(position);

      // Random rotation
      asteroid.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );

      scene.add(asteroid);

      // Create trajectory trail for this asteroid
      const trailPositions = [];
      for (let i = 0; i < 150; i++) {
        trailPositions.push(position.x, position.y, position.z);
      }
      const trailGeometry = new THREE.BufferGeometry();
      trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
      const trailMaterial = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });
      const trail = new THREE.Line(trailGeometry, trailMaterial);
      scene.add(trail);

      // Calculate initial velocity toward the Sun with some randomness
      const directionToSun = new THREE.Vector3(0, 0, 0).sub(position).normalize();

      // Add some bias toward the Sun but with variation (reduced 10x for more realistic speeds)
      const speed = 0.01 + Math.random() * 0.01;
      const velocity = directionToSun.multiplyScalar(speed);

      // Add some perpendicular velocity for more interesting trajectories
      const perpendicular = new THREE.Vector3(-directionToSun.z, 0, directionToSun.x);
      velocity.add(perpendicular.multiplyScalar((Math.random() - 0.5) * 0.01));

      // Store asteroid data
      userAsteroids.push({
        mesh: asteroid,
        velocity: velocity,
        mass: radius * radius * radius, // Mass proportional to volume
        radius: radius,
        rotationSpeed: {
          x: (Math.random() - 0.5) * 0.05,
          y: (Math.random() - 0.5) * 0.05,
          z: (Math.random() - 0.5) * 0.05
        },
        trail: trail,
        trailPositions: [position.clone()],
        maxTrailLength: 150
      });
    }

    // Add click listener
    renderer.domElement.addEventListener('click', onCanvasClick);

    // Labels
    function updateLabels() {
      // Remove existing labels
      document.querySelectorAll('.planet-label').forEach(el => el.remove());

      // Add labels for each planet
      bodies.forEach(body => {
        if (!body.name || body.isMoon) return; // Skip moon labels to avoid clutter

        const position = new THREE.Vector3();
        if (body.container) {
          body.container.getWorldPosition(position);
        } else {
          body.obj.getWorldPosition(position);
        }

        position.project(camera);

        const x = (position.x * 0.5 + 0.5) * window.innerWidth;
        const y = (position.y * -0.5 + 0.5) * window.innerHeight;

        const label = document.createElement('div');
        label.className = 'planet-label';
        label.textContent = body.name;
        label.style.left = `${x}px`;
        label.style.top = `${y}px`;

        document.body.appendChild(label);
      });
    }

    // Animation loop
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;

      // Animate sun pulsing glow
      const sunBody = bodies.find(b => b.name === "Sun");
      if (sunBody) {
        const pulse = Math.sin(time * 2) * 0.1 + 1;
        sunBody.glow1.scale.set(pulse, pulse, pulse);
        sunBody.glow2.scale.set(pulse * 0.95, pulse * 0.95, pulse * 0.95);
        sunBody.glow3.scale.set(pulse * 0.9, pulse * 0.9, pulse * 0.9);

        // Pulse sun light intensity
        sunLight.intensity = 3 + Math.sin(time * 2) * 0.3;
      }

      // Animate star twinkling
      const sizes = starGeometry.attributes.size.array;
      const twinklePhases = starGeometry.attributes.twinklePhase.array;
      for (let i = 0; i < starCount; i++) {
        const twinkle = Math.sin(time + twinklePhases[i]) * 0.3 + 0.7;
        sizes[i] = (Math.random() * 3 + 0.5) * twinkle;
      }
      starGeometry.attributes.size.needsUpdate = true;

      // Slowly rotate nebula clouds
      nebulaGroups.forEach((group, i) => {
        group.rotation.x += 0.0001 * (i % 2 === 0 ? 1 : -1);
        group.rotation.y += 0.0002 * (i % 2 === 0 ? 1 : -1);
      });

      // Animate space dust
      const dustPositions = dustGeometry.attributes.position.array;
      for (let i = 0; i < dustCount; i++) {
        const idx = i * 3;
        dustPositions[idx] += dustVelocities[idx];
        dustPositions[idx + 1] += dustVelocities[idx + 1];
        dustPositions[idx + 2] += dustVelocities[idx + 2];

        // Wrap around
        if (Math.abs(dustPositions[idx]) > 100) dustPositions[idx] *= -1;
        if (Math.abs(dustPositions[idx + 1]) > 100) dustPositions[idx + 1] *= -1;
        if (Math.abs(dustPositions[idx + 2]) > 100) dustPositions[idx + 2] *= -1;
      }
      dustGeometry.attributes.position.needsUpdate = true;

      // Handle camera animation
      if (cameraAnimating) {
        cameraAnimationProgress += 0.02;

        if (cameraAnimationProgress >= 1) {
          cameraAnimationProgress = 1;
          cameraAnimating = false;
        }

        // Smooth easing function
        const t = cameraAnimationProgress;
        const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

        // Interpolate camera position
        camera.position.lerpVectors(cameraStartPos, cameraEndPos, eased);
        controls.target.lerpVectors(cameraStartTarget, cameraEndTarget, eased);
      }

      // Update controls target to follow selected planet
      if (selectedPlanet && !cameraAnimating) {
        const targetPos = new THREE.Vector3();
        if (selectedPlanet.container) {
          selectedPlanet.container.getWorldPosition(targetPos);
        } else {
          selectedPlanet.obj.getWorldPosition(targetPos);
        }
        controls.target.copy(targetPos);
      }

      if (!animationPaused) {
        // Animate asteroids
        asteroidBelt.forEach(asteroid => {
          // Rotate asteroids
          asteroid.mesh.rotation.x += asteroid.rotationSpeed.x * speedFactor;
          asteroid.mesh.rotation.y += asteroid.rotationSpeed.y * speedFactor;
          asteroid.mesh.rotation.z += asteroid.rotationSpeed.z * speedFactor;

          // Orbit asteroids
          asteroid.angle += asteroid.orbitSpeed * speedFactor;
          const x = Math.cos(asteroid.angle) * asteroid.distance;
          const z = Math.sin(asteroid.angle) * asteroid.distance;
          asteroid.mesh.position.x = x;
          asteroid.mesh.position.z = z;
        });

        // Animate comets
        comets.forEach(comet => {
          comet.angle += comet.speed * speedFactor;

          // Calculate elliptical orbit position
          const a = comet.semiMajorAxis;
          const e = comet.eccentricity;
          const b = a * Math.sqrt(1 - e * e);
          const c = a * e;

          const x = a * Math.cos(comet.angle) - c;
          const y = Math.sin(comet.angle * 0.5) * Math.sin(THREE.MathUtils.degToRad(comet.inclination)) * a * 0.3;
          const z = b * Math.sin(comet.angle);

          comet.group.position.set(x, y, z);

          // Update tail particles
          const positions = comet.tail.geometry.attributes.position.array;
          const cometPos = new THREE.Vector3(x, y, z);
          const sunPos = new THREE.Vector3(0, 0, 0);
          const tailDirection = new THREE.Vector3().subVectors(cometPos, sunPos).normalize();

          for (let i = 0; i < 300; i++) {
            const idx = i * 3;
            const spread = (Math.random() - 0.5) * 1.5;
            const length = i * 0.2;
            positions[idx] = tailDirection.x * length + spread;
            positions[idx + 1] = tailDirection.y * length + spread;
            positions[idx + 2] = tailDirection.z * length + spread;
          }
          comet.tail.geometry.attributes.position.needsUpdate = true;

          // Pulse coma
          const comaPulse = Math.sin(time * 3) * 0.2 + 1;
          comet.coma.scale.set(comaPulse, comaPulse, comaPulse);
        });

        // Animate celestial bodies
        bodies.forEach((body, index) => {
          if (body.isMoon) {
            // Moons keep simple circular motion
            body.pivot.rotation.y += body.speed * speedFactor;
          } else if (body.eccentricity !== undefined) {
            // Planets use elliptical motion with variable speed
            body.angle += body.speed * speedFactor;

            // Calculate position on ellipse
            const x = body.semiMajorAxis * Math.cos(body.angle);
            const z = body.semiMinorAxis * Math.sin(body.angle);

            // Calculate distance from focus (Sun)
            const r = Math.sqrt(Math.pow(x + body.focusOffset, 2) + Math.pow(z, 2));

            // Variable speed: faster when closer (simplified Kepler's 2nd law)
            const speedMultiplier = Math.pow(body.semiMajorAxis / r, 1.5);
            body.angle += body.speed * speedFactor * (speedMultiplier - 1) * 0.3;

            // Update position
            if (body.container) {
              body.container.position.set(x, 0, z);

              // Update planet trail
              if (body.trailIndex !== undefined) {
                const worldPos = new THREE.Vector3();
                body.container.getWorldPosition(worldPos);

                const trailData = planetTrails[body.trailIndex];
                trailData.positions.push(worldPos.clone());

                if (trailData.positions.length > trailData.maxLength) {
                  trailData.positions.shift();
                }

                const trailPositions = trailData.trail.geometry.attributes.position.array;
                for (let i = 0; i < trailData.positions.length; i++) {
                  const pos = trailData.positions[i];
                  trailPositions[i * 3] = pos.x;
                  trailPositions[i * 3 + 1] = pos.y;
                  trailPositions[i * 3 + 2] = pos.z;
                }
                trailData.trail.geometry.attributes.position.needsUpdate = true;
              }
            }
          }

          // Self-rotation for all bodies
          body.obj.rotation.y += body.selfRotationSpeed * speedFactor;

          // Animate ring shimmer
          if (body.rings && body.rings.length > 0) {
            body.rings.forEach((ringData, ringIndex) => {
              const shimmer = Math.sin(time * 1.5 + ringIndex) * 0.15 + 0.85;
              ringData.material.opacity = ringData.baseOpacity * shimmer;
              ringData.material.emissiveIntensity = 0.1 + Math.sin(time * 2 + ringIndex) * 0.05;
              ringData.mesh.rotation.z += 0.0001 * speedFactor;
            });
          }
        });

        // Animate Starlink satellites
        starlinkSatellites.forEach(sat => {
          // Orbit around Earth
          sat.angle += sat.speed * speedFactor * 0.5;
          const x = sat.orbitRadius * Math.cos(sat.angle);
          const z = sat.orbitRadius * Math.sin(sat.angle);
          sat.mesh.position.set(x, 0, z);

          // Slight rotation for realism
          sat.mesh.rotation.y += 0.01 * speedFactor;
        });

        // Animate user-placed asteroids with physics
        const asteroidsToRemove = [];
        userAsteroids.forEach((asteroid, index) => {
          // Apply gravity from Sun
          const sunPos = new THREE.Vector3(0, 0, 0);
          const toSun = new THREE.Vector3().subVectors(sunPos, asteroid.mesh.position);
          const distanceToSun = toSun.length();

          if (distanceToSun > 0.1) {
            const sunMass = 1000; // Relative mass of sun
            const gravityForce = (G * sunMass) / (distanceToSun * distanceToSun);
            const gravityAccel = toSun.normalize().multiplyScalar(gravityForce);
            asteroid.velocity.add(gravityAccel.multiplyScalar(speedFactor));
          }

          // Apply gravity from planets
          bodies.forEach(body => {
            if (body.name === "Sun" || body.isMoon) return;

            const planetPos = new THREE.Vector3();
            if (body.container) {
              body.container.getWorldPosition(planetPos);
            } else {
              body.obj.getWorldPosition(planetPos);
            }

            const toPlanet = new THREE.Vector3().subVectors(planetPos, asteroid.mesh.position);
            const distanceToPlanet = toPlanet.length();

            if (distanceToPlanet > 0.1) {
              // Planet mass based on radius
              const planetRadius = body.obj.geometry.parameters.radius || 1;
              const planetMass = planetRadius * planetRadius * planetRadius * 50;
              const gravityForce = (G * planetMass) / (distanceToPlanet * distanceToPlanet);
              const gravityAccel = toPlanet.normalize().multiplyScalar(gravityForce);
              asteroid.velocity.add(gravityAccel.multiplyScalar(speedFactor));
            }

            // Check for collision with planet
            const planetRadius = body.obj.geometry.parameters.radius || 1;
            if (distanceToPlanet < planetRadius + asteroid.radius) {
              asteroidsToRemove.push(index);
              return;
            }
          });

          // Check for collision with Sun
          if (distanceToSun < 3 + asteroid.radius) {
            asteroidsToRemove.push(index);
            return;
          }

          // Check for escape
          if (distanceToSun > ESCAPE_DISTANCE) {
            asteroidsToRemove.push(index);
            return;
          }

          // Update position
          asteroid.mesh.position.add(asteroid.velocity.clone().multiplyScalar(speedFactor));

          // Update trail
          asteroid.trailPositions.push(asteroid.mesh.position.clone());
          if (asteroid.trailPositions.length > asteroid.maxTrailLength) {
            asteroid.trailPositions.shift();
          }

          const trailPosArray = asteroid.trail.geometry.attributes.position.array;
          for (let i = 0; i < asteroid.trailPositions.length; i++) {
            const pos = asteroid.trailPositions[i];
            trailPosArray[i * 3] = pos.x;
            trailPosArray[i * 3 + 1] = pos.y;
            trailPosArray[i * 3 + 2] = pos.z;
          }
          asteroid.trail.geometry.attributes.position.needsUpdate = true;

          // Rotate asteroid
          asteroid.mesh.rotation.x += asteroid.rotationSpeed.x * speedFactor;
          asteroid.mesh.rotation.y += asteroid.rotationSpeed.y * speedFactor;
          asteroid.mesh.rotation.z += asteroid.rotationSpeed.z * speedFactor;
        });

        // Remove collided/escaped asteroids
        asteroidsToRemove.reverse().forEach(index => {
          scene.remove(userAsteroids[index].mesh);
          scene.remove(userAsteroids[index].trail);
          userAsteroids[index].mesh.geometry.dispose();
          userAsteroids[index].mesh.material.dispose();
          userAsteroids[index].trail.geometry.dispose();
          userAsteroids[index].trail.material.dispose();
          userAsteroids.splice(index, 1);
        });
      }

      controls.update();
      updateLabels();

      // Use post-processing if available, otherwise use standard rendering
      if (usePostProcessing && composer) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (usePostProcessing && composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    animate();
  </script>
  <script src="index.js"></script>
</body>

</html>
